<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <script>
    // --------------------------

  let globalVar = "I’m global";
function outer() {
  let functionVar = "I’m in function scope";
  if (true) {
    // var blockVar = "I’m in block scope";       //var has function scope
    let blockVar = "I’m in block scope";        //let and const have block scope
    console.log(globalVar);   // ✅ accessible
    console.log(functionVar); // ✅ accessible
    console.log(blockVar);    // ✅ accessible
  }
  // console.log("OUTSIDE BLOCK",blockVar); // ❌ ReferenceError
}
outer();
// console.log(functionVar); // ❌ ReferenceError

//     Execution Priority
//     1️⃣ Synchronous code
// 2️⃣ Microtask Queue (Promises)
// 3️⃣ Callback Queue (setTimeout etc.)

    // console.log("Start");
 
    // setTimeout(() => {
    // console.log("Inside setTimeout");
    // }, 1000);
    
    // console.log("End")


    //     console.log("First");
    // setTimeout(() => {
    // console.log("Second");
    // }, 0);
    // console.log("Third");

    // function testScope() {
    //     if (true) {
    //       var a = 1;      //var is function scoped, NOT block scoped.
    //       let b = 2;        //let is block scoped, meaning it only exists inside the { }
    //       const c = 3;
    //     }
    //     console.log(a);       //So a is available anywhere inside testScope().
    //     console.log(b);
    //     console.log(c);
    //   }

    //   testScope();

    // async function fetchAllTheProducts(data) { ... }
//     function declaration
//     JavaScript moves both the function name and its definition to the top of the scope before execution.


//     const fetchAllTheProducts = async (data) => { ... };
//     function expression
// this is not a function declaration — it’s a function expression assigned to a variable.
// JavaScript hoists only the variable name (fetchAllTheProducts) to the top.
// Because it’s declared with const, the variable is in the temporal dead zone (TDZ) — meaning you cannot use it until that line of code is executed.
    //https://chatgpt.com/c/68f349a4-af98-8322-a1b2-d2da316c3c47

    // const emptyPlanetsArr = [
    //   "tatooine",
    //   "alderaan",
    //   "yavin iv",
    //   "hoth",
    //   "dagobah",
    //   "bespin",
    //   "endor",
    //   "naboo",
    //   "coruscant",
    //   "kamino",
    // ];

    // const searchPlanetInput = window.prompt("Enter value");
    // const matchedValues = emptyPlanetsArr?.filter((item) =>
    //   item.includes(searchPlanetInput.toLowerCase())
    // );
    // console.log(matchedValues);

    // console.log([] == [])
    // console.log([] !== [])
    // console.log(![] == ![])
    // console.log(!true == [])
    // console.log(![] == [])    

    // if pay1[item] === pay2[item]
    // As soon as the loop checks the first item and finds that pay1[item] === pay2[item],
    // it will execute the else block and immediately return "Same Payload".
    // This causes the function to stop without fully checking all other key-value pairs.

      //  function samePayload(a, b) {
      // const aLength = Object.keys(a).length;
      // const bLength = Object.keys(b).length;
      // const keys = Object.keys(a);

    //   if (aLength !== bLength) {
    //     return "Not Same";
    //   }

    //   for (let key of keys) {
    //     if (a[key] !== b[key]) {
    //       return "Not Same Keys"; //This Exits the function
    //     }
    //   }

    //   keys.forEach((item)=>{
    //     if(a[item]!==b[item]){
    //       return "Not Same Keys"      // This only exits the callback
    //     }
    //     return "Same Keys"      // This only exits the callback
    //   })
    // }

    // SWAPPING
    // let a = 66;let b = 9;let c=55;
    // let temp
    // temp = a
    // a = b
    // b = temp
    // console.log(a,b);

    // [a,b] = [b,a];
    // console.log(`A`,a);
    // console.log(`B`,b);

    // FLATTING
    // const arr = [1,[2,[3,4,5]]]
    // console.log(arr.flat(Infinity));

    //SHUFFLING
    // const arr = [1, 2, 3, 4, 5];

    // function shuffleArr(data){
    //   for (let i = data.length-1; i > 0; i--) {
    //     console.log(`--I--`,i);
    //     const j = Math.floor(Math.random()*(i+1));
    //     [data[i],data[j]] = [data[j],data[i]]
    //   }
    //   return data
    // }

    // console.log(shuffleArr([...arr]));

    // console.log("--arr--",arr);
    
    
    // //Fisher–Yates
    // for (let i = arr.length - 1; i > 0; i--) {
    //   console.log("I---", i);
      
    //   const j = Math.floor(Math.random() * (i + 1)); // random index from 0 to i
    //   [arr[i], arr[j]] = [arr[j], arr[i]]; // swap
    // }

    // for (let i = arr.length - 1; i > 0; i--) {
    //   const j = Math.floor(Math.random()*(i+1));
    //   [arr[i],arr[j]] = [arr[j],arr[i]]
    // }
    // const ascendingOrder = arr.sort((a, b) => a - b);
    // const descendingOrder = arr.sort((a, b) => b - a);
    // console.log(ascendingOrder);
    // console.log(descendingOrder);

    //Math.random() returns a random number between 0 and 1.
    //Subtracting 0.5 shifts the range to between -0.5 and +0.5.

    // const shuffleArr = arr.sort(() => Math.random() - 0.5);
    // console.log(shuffleArr);

    // console.log(arr);

    // const arr = [1, 2, 3, 4, 5];
    // function shuffle(array) {
    //   for (let i = array.length - 1; i > 0; i--) {
    //     console.log("I---",i);

    // // Pick a random index from 0 to i
    //     const j = Math.floor(Math.random() * (i + 1));
    //     // Math.random() gives a number between 0 and 1.
    //     console.log("---------J----------",j);

    // // Swap elements at i and j
    //     [array[i], array[j]] = [array[j], array[i]];
    //   }
    //   return array;
    // }
    // console.log(shuffle([...arr]));

    // console.log([] + []);      // ""   (empty string)
    // console.log([] + {});      // "[object Object]"
    // console.log({} + []);      // 0
    // console.log(typeof NaN);    // "number"
    // console.log("true" == true);  // false
    // console.log(null == undefined); // true
    // console.log([] == 0);      // true
    // console.log([] == ![]);     // true (what?!)

    //   const url = [
    //   'https://pokeapi.co/api/v2/pokemon?limit=1',
    //   'https://pokeapi.co/api/v2/pokemon?limit=2',
    //   'https://pokeapi.co/api/v2/pokemon?limit=3',
    //   'https://pokeapi.co/api/v2/pokemon?limit=4',
    //   'https://pokeapi.co/api/v2/pokemon?limit=5',
    //   'https://pokeapi.co/api/v2/pokemon?limit=6',
    //   'https://pokeapi.co/api/v2/pokemon?limit=7',
    //   'https://pokeapi.co/api/v2/pokemon?limit=8',
    //   'https://pokeapi.co/api/v2/pokemon?limit=9',
    //   'https://pokeapi.co/api/v2/pokemon?limit=10'
    // ];

    // async function getAllData(){
    // try {
    //   const resp = await Promise.all(url.map((item)=>fetch(item)))
    //   const respJSON = await Promise.all(resp.map((item)=>item.json()))
    //   console.log("respJSON",respJSON);

    // } catch (error) {
    //   consol.log("error",error)
    // }
    // }

    // async function getAllData(){
    //   await Promise.all(url.map((item)=>fetch(item)))
    //   .then(async(resp)=> Promise.all(resp.map((item)=>item.json())))
    //   .then((resp)=>console.log("resp",resp))
    //   .catch((err)=>console.log("err",err))
    // }

    // getAllData()

    // async function newFunc(){
    //   try {
    //     const resp = await Promise.all(url.map((item)=>fetch(item)));
    //     const respJson = await Promise.all(resp.map((item)=>item.json()))
    //     console.log(respJson);
    //   } catch (error) {
    //     console.log("error",error);
    //   }
    // }

    // newFunc()

    // ------------------------

    // personInfo.apply(person, ["25"]);
    // const bindFn = personInfo.bind(person, "25");
    // console.log(bindFn);

    // console.log(personInfo.myCallFn(person,"25"));
    // console.log(personInfo.myApplyFunc(person,["25"]));
    // const bindFn = personInfo.myBind(person,"25");
    // bindFn();

    // myFunction.apply(person,"25")
    // const apply = myFunction.bind(person,"25")
    // console.log(apply());

    // myFunction.call(person,"25")
    // myFunction.apply(person,"25")
    // const apply = myFunction.bind(person,"25")
    // console.log(apply());

    //     Function.prototype.myCall = function (context, ...args) {
    //       //globalThis refers to the global object in any JavaScript environment:
    //   context = context || globalThis;
    //   const fnSymbol = Symbol(); // avoid name collision
    //   context[fnSymbol] = this;
    //   const result = context[fnSymbol](...args);
    //   delete context[fnSymbol];
    //   return result;
    // };

    // function greet(greeting) {
    //   console.log(`${greeting}, ${this.name}`);
    // }

    // const person = { name: "Ritik" };
    // greet.myCall(person, "Hello"); // Hello, Ritik

    // Function.prototype.myApply = function (context, args) {
    //   context = context || globalThis;
    //   const fnSymbol = Symbol();
    //   context[fnSymbol] = this;
    //   const result = args ? context[fnSymbol](...args) : context[fnSymbol]();
    //   delete context[fnSymbol];
    //   return result;
    // };

    // greet.myApply(person, ["Hi"]); // Hi, Ritik

    // Function.prototype.myBind = function (context, ...bindArgs) {
    //   const fn = this;
    //   return function (...callArgs) {
    //     return fn.apply(context, [...bindArgs, ...callArgs]);
    //   };
    // };

    // const greetPerson = greet.myBind(person, "Hey");
    // greetPerson();

    // -------------------------------------------

    //PRESENT IN ARRAY
    // const arr = [10, 20, 30];
    // console.log(1 in arr); // true — because index 1 exists (value = 20)
    // console.log(5 in arr); // false — index 5 does not exist

    // ---------------

    // ==call(), apply(), and bind() are methods used to control the this context of a function.
    // call a function with a specific this value, but they differ in syntax and behavior

    // function helloFunc(args){
    //   console.log(`Hi Mr. ${this.name} chauhan,You are ${args}`);
    // }

    // const person = {name:"Ritik"}
    // helloFunc.call(person,25)
    // helloFunc.apply(person,[25])
    // const bind = helloFunc.bind(person,[25])
    // bind();

    // CALL : Calls the function immediately && Calls a function with a given this and args
    //     function greet(age) {
    //       console.log("age",age);

    //   console.log(`Hello, my name is ${this.name} and I am ${age}`);
    // }
    // const person = { name: "Ritik" };
    // greet.call(person, 25); // Hello, my name is Ritik and I am 25

    // apply : Calls the function immediately && takes arguments as an array
    // greet.apply(person, [25]);

    // bind : Returns a new function with bound this, doesn't call it immediately
    // const boundGreet = greet.bind(person);
    // console.log(boundGreet);

    // boundGreet(25); // Hello, my name is Ritik and I am 25

    // function welcomeFunc(arg){
    //   console.log(`Hi ${this.name}.You are ${arg} old.`)
    // }

    // const person={name:"Ritwik Vats"}

    // Function.prototype.myBindFunc=function(context,...args){
    //   const fn = this;
    //   return function (...props){
    //     fn.apply(context,[...args,...props])
    //   }
    // }

    // const ff = welcomeFunc.myBindFunc(person,21)
    // console.log(ff())

    // Function.prototype.callFunc = function(context,...args){
    //   context = context || globalThis();
    //   const fnSymbolFunc = Symbol();
    //   context[fnSymbolFunc] = this;
    //   const result = context[fnSymbolFunc](...args);
    //   return result
    // }

    // Function.prototype.myApplyFunction = function(context,args){
    //   context = context || globalThis();
    //   const fnSymbolFunc = Symbol();
    //   context[fnSymbolFunc] = this
    //   const result = args ? context[fnSymbolFunc](...args) : context[fnSymbolFunc]()
    //   return result
    // }

    // Function.prototype.myBindFunc = function(context,...args){
    //   const fn = this;
    //   return function(...childArgs){
    //     return fn.apply(context,[...args,...childArgs])
    //   }
    // }

    // const bind = welcomeFunc.myBindFunc(person,[29])
    // bind()

    // welcomeFunc.apply(person,[29])
    // const bindFunc = welcomeFunc.bind(person,29)
    // bindFunc();

    // welcomeFunc.call(person,29)
    // welcomeFunc.apply(person,[29])
    // const bindFunc = welcomeFunc.bind(person,29)
    // bindFunc();

    // -------------------------------------------------------

    // const arr = [1, 2, 3, 4, 5];

    // const mapFn = arr.map((item) => item * 2);
    // const myFilterFn = arr.filter((item) => item % 2 === 0);
    // const myReduceFn = arr.reduce((x, y) => x + y);
    // console.log(mapFn);
    // console.log(myFilterFn);
    // console.log(myReduceFn);

    // Array.prototype.myMapFn=function(calbck){
    //   const emptyArr = []
    //   for (let i = 0; i < this.length; i++) {
    //     emptyArr.push(calbck(this[i],i,this))
    //   }

    //   return emptyArr
    // }

    // Array.prototype.myFilterFunc = function(calbck){
    //   const emptyArr = []
    //   for (let i = 0; i < this.length; i++) {
    //     if(calbck(this[i],i,this)){
    //       emptyArr.push(this[i])
    //     }
    //   }

    //   return
    // }

    // Array.prototype.myReduceFn = function(calbck,initialValue){
    //   const array = this;
    //   let startIndex = 0
    //   let accumulator

    //   if(initialValue!==undefined){
    //     accumulator = initialValue
    //   }

    //   while(startIndex<array.length && !(startIndex in array)){
    //     startIndex++
    //   }
    //   if(startIndex>=array.length){
    //     throw new Error("Error");
    //   }

    //   accumulator = array[startIndex]
    //   startIndex++

    //   for (let i = startIndex; i < array.length; i++) {
    //     accumulator = calbck(accumulator,array[i],i,array)
    //   }

    //   return accumulator
    // }

    // const mapFn = arr.myMapFn((item)=>item*2);
    // const myFilterFn = arr.myFilterFunc((item)=>item%2===0);
    // const myReduceFn = arr.myReduceFn((x,y)=>x+y)

    // console.log(mapFn);
    // console.log(myFilterFn);
    // console.log(myReduceFn);

    // const newArr = arr.myFilterFunc((item,index)=>item%2===0);
    // console.log(newArr);

    // Array.prototype.myMap=function(callback){
    //   const emptyArr = [];
    //   for (let i = 0; i < this.length; i++) {
    //     emptyArr.push(callback(this[i],i,this))
    //   }

    //   return emptyArr
    // }

    // Array.prototype.mpMapFunction = function(callBack){
    //   const emptyArr = []
    //   for (let i = 0; i < this.length; i++) {
    //     emptyArr.push(callBack(this[i],i,this))
    //   }

    //   return emptyArr
    // }

    //this refers to the array on which myMap or myFilter is called
    //     Array.prototype.myMap = function(callback) {
    //   const result = [];
    //   console.log("this",this);
    //   for (let i = 0; i < this.length; i++) {
    //     // Skip empty slots for sparse arrays
    //       result.push(callback(this[i], i, this));
    //   }
    //   return result;
    // };

    // Array.prototype.myMapFunction=function(callback){
    //   const result=[];
    //   for (let i = 0; i < this.length; i++) {
    //     result.push(callback(this[i],i,this))
    //   }

    //   return result
    // }

    // const arr = [1, 2, 3];

    // const ee = arr.myMap((it)=>it*2)
    // console.log(ee);

    // const doubled = arr.myMap(x => x * 2);
    // console.log(doubled);
    // --------------------------------------------

    // Array.prototype.myFilter = function(callback){
    //   const emptyArr = [];
    //   for (let i = 0; i < this.length; i++) {
    //     if(callback(this[i],i,this)){
    //     emptyArr.push(this[i])
    //   }
    //   }

    //   return emptyArr
    // }

    // Array.prototype.myFilterFunction = function (callBack){
    //   const emptyArr = [];
    //   for (let i = 0; i < this.length; i++) {
    //     if(callBack(this[i],i,this)){
    //       emptyArr.push(this[i])
    //     }
    //   }

    //   return emptyArr
    // }

    // const arr = [1,2,3,4,5];
    // const filteredArr = arr.myFilterFunction((item,index)=>item%2===0);
    // console.log(filteredArr);

    // Array.prototype.myFilter = function(callBack){
    //   const emptyArr = []
    //   for (let i = 0; i < this.length; i++) {
    //     if(callBack(this[i],i,this)){
    //       emptyArr.push(this[i])
    //     }
    //   }
    //   return emptyArr
    // }
    // Array.prototype.myFilter = function(callback) {
    //   const result = [];
    //   for (let i = 0; i < this.length; i++) {
    //     // Skip empty slots
    //       if (callback(this[i], i, this)) {
    //         result.push(this[i]);
    //       }
    //   }
    //   return result;
    // };

    // const nums = [1, 2, 3, 4, 5];
    // const arrt = nums.myFilter((it)=>it%2===0)
    // console.log(arrt);

    // const evens = nums.myFilter(n => n % 2 === 0);
    // console.log(evens);

    // // --------------------------------------

    // CORRECT ONE
    // Array.prototype.myReduce = function(callback, !==undefined){} {
    //   if (typeof callback !== "function") {
    //     throw new TypeError(callback + " is not a function");
    //   }

    //   const array = this;
    //   let accumulator;
    //   let startIndex = 0;

    //   // Handle initialValue
    //   if (initialValue !== undefined) {
    //     accumulator = initialValue;
    //   } else {
    //     // Find first defined value for sparse arrays
    //     while (startIndex < array.length && !(startIndex in array)) {
    //       startIndex++;
    //     }

    //     if (startIndex >= array.length) {
    //       throw new TypeError("Reduce of empty array with no initial value");
    //     }

    //     accumulator = array[startIndex];
    //     startIndex++;
    //   }

    //   // Iterate over the array
    //   for (let i = startIndex; i < array.length; i++) {
    //     if (i in array) {
    //       accumulator = callback(accumulator, array[i], i, array);
    //     }
    //   }

    //   return accumulator;
    // };

    // --------------

    // Array.prototype.myReduceFunction = function(callBack,initialValue){
    //   const array = this;
    //   let accumulator;
    //   let startIndex=0

    //   if(initialValue!==undefined){
    //     accumulator = initialValue
    //   }
    //   else{
    //     while(startIndex<array.length && !(startIndex in array)){
    //       startIndex++
    //     }

    //     if(startIndex>=array.length){
    //       throw new Error("Error");
    //     }

    //     accumulator = array[startIndex];
    //     startIndex++
    //   }

    //   for (let i = 0; i < array.length; i++) {
    //     if(i in array){
    //       accumulator = callBack(accumulator,array[i],i,array)
    //     }

    //   }

    //   return accumulator
    // }

    //--------------------------------------
    // const arr = [10, 20, 30, 40, 50]

    // const arr = [10, 20, 30, 40, 50];

    // function sumAll(data){
    //   let sum = 0
    //   // for (let i = 0; i <= data.length; i++)     //When i = 5 → data[5] = undefined
    //   for (let i = 0; i < data.length; i++) {
    //     sum = data[i] + sum     //and undefined + sum = NAN
    //   }
    //   // data.forEach(element => {
    //   //   sum+=element
    //   // });
    //   return sum
    // }

    // console.log(sumAll(arr));

    // const suMFunc=(data)=>{
    //   let sum= 0
    //   for (let i = 0; i < data.length; i++) {
    //     sum+=data[i]
    //   }
    //   console.log(sum);
    //   return sum
    // }
    // console.log(suMFunc(arr));

    // -----------------------------------

    //->Only copies the first level of an object or array.
    //->Nested objects or arrays are still referenced
    // =>So name remain unchanged but city changes
    // const original = {
    //   name: "Ritik",
    //   address: { city: "Delhi" },
    // };

    // const shallowCopy = { ...original };

    // shallowCopy.name = "Chauhan";
    // shallowCopy.address.city = "Mumbai";

    // console.log(original.name); // Ritik ❌→ Chauhan (not affected)
    // console.log(original.address.city);

    // ----------

    // Creates a true copy of the entire structure, including nested objects/arrays.
    // Changes made in the copy won’t affect the original.

    // const original = {
    //   name: "John",
    //   address: {
    //     city: "Delhi"
    //   }
    // };

    // // // Deep clone using JSON (works only for simple objects)
    // const deepClone = JSON.parse(JSON.stringify(original));

    // deepClone.address.city = "Mumbai";
    // deepClone.name = "RitikChauhan";

    // console.log(original.address.city);
    // console.log(original.name);

    // console.log(deepClone.address.city);
    // console.log(deepClone.name);

    // --------

    //Optional chaining is only allowed when accessing values, not when assigning to them.
    //You cannot assign to something that might be undefined – it defeats the purpose of assignment safety.
    // error : Support for the experimental syntax 'optionalChainingAssign' isn't currently enabled

    // const x = obj?.prop; // ✅ valid
    // obj?.prop = 123;     // ❌ invalid

    // Computed Property Names
    // const handleChange = (e) => {
    //   const { name, value } = e.target;
    //   setUser((prev) => ({
    //     ...prev,
    //     [name]: value,    //they're using a JavaScript feature called "computed property names
    //   }));
    // };
    //Without the brackets, it would literally create a key named "name" for email like
    //   {
    //   name: "user@example.com"
    // }

    //Instead of hardcoding a property name, you compute it at runtime using square brackets
    // const key = "email";
    // const obj = {
    //   [key]: "example@example.com"
    // };
    // console.log(obj);

    // const obj = {
    //   key: "example@example.com"
    // };
    // console.log(obj); // { key: "example@example.com" } ❌ Not dynamic

    // -------------------------------------------------

    // var Hoisting
    // console.log(x); // undefined (NOT ReferenceError)
    // var x = 5;

    // // Internally JS does:
    // var x;         // declaration hoisted
    // console.log(x); // undefined
    // x = 5;         // initialization

    //  Temporal Dead Zone (TDZ)
    // The Temporal Dead Zone is the time between hoisting and declaration where accessing a let or const variable causes a ReferenceError.
    // a is hoisted but not initialized.
    // console.log(a); // ❌ ReferenceError
    // let a = 20;

    // ---------------------------------------------------------

    // A variable is not defined if you try to use it without declaring it first.
    // console.log(x); // ❌ ReferenceError: x is not defined

    // let x;       //A variable is declared but not assigned a value
    // console.log(x); // undefined

    // function test() {}     // A function doesn’t return anything.
    // console.log(test()); // undefined

    // let obj = {};
    // console.log(obj.key);

    // let a;
    // console.log(a);        // undefined
    // console.log(b);        // ❌ ReferenceError: b is not defined

    // --------------------

    // console.log('Start');
    // setTimeout(() => {
    //   console.log('Macrotask - setTimeout');
    // }, 0);
    // Promise.resolve().then(() => {
    //   console.log('Microtask - Promise');
    // });
    // console.log('End');

    // Start
    // End
    // Microtask - Promise (High-priority tasks, run immediately after the current execution context and before any rendering)
    // Macrotask - setTimeout

    // const user = {username:"Ritik"}
    // const key = [[[["username"]]]]  //When arrays are used as keys or property accessors, JavaScript coerces them to strings using .toString().
    // console.log(user[key]);   //JavaScript implicitly converts the array to a string
    // key == [[[["username"]]]] → becomes "username" (because of array to string coercion)
    // console.log([[["username"]]].toString());

    // console.log([]+{})    //"" + "[object Object]" → "[object Object]"
    // console.log({} + [])

    // output.forEach(async (item) => {
    //   await assignToUser(item.mandate_id, code, item.rating_process_uuid);
    // });

    // for (const item of output) {//It waits for each assignToUser() call to complete before going to the next item.
    // await assignToUser(item.mandate_id, code, item.rating_process_uuid);
    //   }
    //for...of with await runs each assignToUser() call sequentially, waiting for each one to finish.
    // Always use for...of (or for, while) when you need to use await inside a loop and want it to actually wait.

    // .forEach() doesn't wait for async callbacks.
    //So even though you're using await inside the callback, the outer function doesn't pause for them to finish.

    //   const items = [1, 2, 3];

    // items.forEach(async (item) => {
    //   await new Promise((resolve) => setTimeout(resolve, 1000));    //it didn't wait for 1 sec
    //   console.log(item);
    // });

    // console.log("Done");

    // const items = [1, 2, 3];

    // async function processItems() {
    //   for (const item of items) {
    //     await new Promise((resolve) => setTimeout(resolve, 1000));   //it waits for 1 sec
    //     console.log(item);
    //   }
    // }
    // console.log("Done");

    // processItems();

    // FOR IN
    // Note : Use array notation in forin and forof loops to get a value
    // const obj = { a: 1, b: 2, c: 3 }

    // for (const key in obj) {
    //   console.log("---key---",key);
    //   console.log(obj[key]);
    // }

    // for (const key in obj) {
    //   console.log(obj[key]);
    // }

    // const keys = Object.keys(obj)
    // const values = Object.values(obj)
    // console.log("KEYS",keys);
    // console.log("VALUES",values);

    // for (let key in obj) {
    //   console.log("key",key); // Output: 'a', 'b', 'c'
    //   console.log("value",obj[key]); // Output: 1, 2, 3
    // }

    // // FOR OF
    // const arr = [1,2,8,3];

    // for (const element of arr) {
    // console.log("element",element);
    // console.log(arr[element]);  //arr[1],arr[2],arr[8]
    // }

    // for (const element of arr) {
    //   console.log(element);
    // }

    // for (let value of arr) {
    //   console.log(value); // Output: 1, 2, 3
    // }

    // const [key,value] = [["firstName","John"],["lastName","Doe"],["age",30],["arr",["John","qwe"]]]
    //   console.log("key",key);
    //   console.log("value",value);

    const person = {
      firstName: "John",
      lastName: "Doe",
      age: 30,
      arr: ["John", "qwe"],
    };

    // console.log(Object.entries(person));

    // for (const [key,value] of Object.entries(person)) {
    //   console.log("key",key);
    //   console.log("--value--",value);
    // }

    // for (const [key,value] of Object.entries(person)) {
    //   console.log("key",key);
    //   console.log("value",value);
    // }

    // console.log(Object.entries(person)); //it creates array of arrays containing keys and values
    // console.log(Object.keys(person));
    // console.log(Object.values(person));
    // for (const [key,value] of Object.entries(person)) {  //to extract keys and values [arrValue1,arrValue2] = [1,2]
      // const [key,value] = [["firstName","John"],["lastName","Doe"],["age",30],["arr",["John","qwe"]]]
    //   console.log("key",key);
    //   console.log("value",value);
    // }
    // for (const data of Object.entries(person)) {
    //   console.log("data",data);
    // }

    // Note:

    // check if they both contains same items or not
    // const a = [1, 2, 3];
    // const b = [1, 3, 2];

    // const ascendingsort = (arr)=>{
    //     const newArr = [...arr]; // make a copy to avoid mutating the original
    //     for (let i = 0; i < newArr.length; i++) {
    //       console.log("IIIIII Value",newArr[i]);
    //       for (let j = 0; j < newArr.length - 1 - i; j++) {
    //         console.log("first Value",newArr[j]);
    //         console.log("---second---",newArr[j+1]);
    //         if(newArr[j] > newArr[j+1]){
    //         const emptyArr = newArr[j]
    //         newArr[j] = newArr[j+1]
    //         newArr[j+1] = emptyArr
    //       }
    //     }
    //   }
    //   return newArr
    // }

    // console.log(ascendingsort(b));

    // const equalItem = a.length === b.length && a.every((item)=>b.includes(item))
    // const conditioon = a.length === b.length && a.every((item)=>b.includes(item))

    // console.log("equalItem",equalItem);

    // console.log(conditioon);

    // console.log(b.sort().reverse());

    // const sameItems = (obj1,obj2)=>{
    //   if(obj1?.length !== obj2.length){
    //     return "Not same"
    //   }
    //   // const dd =obj1.every((it)=>obj2.includes(it))
    //   const dd =   JSON.stringify(obj1.sort()) === JSON.stringify(obj2.sort())
    //   return dd ? "Same" : "Not same"
    // }

    // console.log("ss",sameItems(a,b));

    // const check = a.every((item)=>b.includes(item));
    // console.log(check);

    // const sameArr = a.length === b.length && a.every((item)=>b.includes(item))
    // console.log("sameArr",sameArr);

    // NOTE : null equals to null or undefined
    // console.log(null===null);
    // console.log(null===undefined);
    // console.log(null==undefined);
    // console.log(typeof(null));
    // console.log(typeof(undefined));   //undefined
    // console.log(null == 0);
    // console.log(null == '');

    //Type Coercion
    // Numeric to String Coercion:
    // var num = 42;
    // var str = "The answer is " +  num; // Coercion: number to string
    // console.log(str); // Output: "The answer is 42"
    // console.log(typeof str);

    // String to Numeric Coercion:
    // var str = "jh42s";
    // var str = "42";
    // var num = +str; // Coercion: string to number
    // console.log(num);
    // console.log(typeof num); // Output: 42

    //When an operation like subtraction (-), multiplication (*), division (/), or modulus (%) not (+) is performed, all the values that are not numbers are converted into the number data type
    // console.log(10 % "5")
    // console.log(10 / "5")
    // let cc = 10 % "5"
    // let cc = 10 / "5"
    // console.log(cc);
    // console.log(typeof(cc));
    // console.log("number" + 15 + 3)  //+ has left-to-right associativity, so expression "number" + 15
    // console.log(15 + 3 + "number" )
    // console.log(15 + 3 + +"number" )
    //Boolean to Number
    // console.log(false + 2); //converts false to 0 and then 0 + 2
    // console.log(Number(null));
    // console.log(Number(undefined));   //Its NAN
    // https://www.freecodecamp.org/news/js-type-coercion-explained-27ba3d9a2839

    // Comparison Coercion:(== , !=) converts string to number (ONLY ==)
    // comparison operators (>, <, <=,>=)
    // bitwise operators ( | & ^ ~)
    // console.log('true' == true);  //== operator triggers numeric conversion,;'true' is converted to number i.e, to NaN and true is 1
    // console.log(42 == "42");  //In this case, the loose equality operator == coerces the string "42" into a number before comparing it with the number 42.
    // console.log([]=="");
    // console.log([]==![]);   //here ![] == false then "" == ""    //![] = 0
    // !coverts it to boolean(false) JavaScript attempts to convert the operands to the same type.
    // "" == 0    //type coercion if the operands are of different types
    //0 == 0    //again coercion
    // console.log(true + "10"); // Boolean TO STRING The Boolean value true is converted to string 'true'
    // console.log("10" + true);
    // console.log(true + +"10");
    // console.log(true + 10); //Boolean To NUMBER
    // console.log(12 / "6"); //Arithmetic division operator / triggers numeric (12/6)
    // console.log([1] > null);      //Comparison operator triggers numeric conversion  null will become 0
    // console.log(!!"false" == !!"true"); //sinnce they are non-empty strings so both are true
    // console.log(['x'] == 'x');    //Array’s toString() converts ['x'] to just 'x' string.
    // console.log([] + null + 1);   //empty array in ""
    // console.log(3 > 2 >= 1);    //true
    // console.log(3 > 2 > 1);    //false as 1>1
    // console.log(1 > 2 > 3); //false non-numeric value to a number
    // console.log(2 > 1 > 0); //true non-numeric value to a number
    // console.log("%cHello World","color:yellow");
    // console.log("%cThis is a red text", "color:red");
    // const person = {
    //   name: "batMan",
    //   age: 21,
    // };
    // console.log(Object.entries(person))
    // for (const [key,array] of Object.entries(person)) {
    //   console.log("key",key);
    //   console.log("array",array);
    // }
    // console.log(Object.keys(person)); //gives array of keys
    // console.log(Object.values(person)); //gives array of values
    // for (const item in person) {
    //   //it will give keys of object
    //   console.log(item);
    //   console.log(person[item]);
    // }

    // const obj = { 1: "a", name: "b", 3: "c" }; //we can define an obj key as an number but not var,let name
    // console.log(obj.hasOwnProperty("1")); //you can use that number as string or number it works for
    // console.log(obj.hasOwnProperty("name")); //both
    // console.log(Object.keys(obj).length);
    // console.log("obj", obj);

    // const arr = [10, 10, 10, 10, 10, 10,].map(parseInt); //parseInt("10", 1) The radix is 1, which is not a valid radix. Therefore, NaN is returned.
    // console.log(arr); //parseInt("10", 2) is called. The radix is 2, so "10" is interpreted as a binary number, and the result is 2

    // It's due to different scopes of both the variables
    // var num = 8; //memory allocated to num variable with a variable
    // function display() {
    //   //memory allocated to display()
    //   num = 10;
    //   console.log(num);
    // }
    // display(); //function is called
    // console.log(num);

    // var num = 8;
    // function display() {
    //   var num = 10;
    //   console.log(num);
    // }
    // display();
    // console.log(num);

    // console.log("2" * "8")    //multiplication operator (*) implicitly converts the string values to numbers before performing the multiplication.
    // console.log("2" + "4" * "2")  	  //BODMAS ; When + is used with -,* etc
    // console.log("2" + "4" * "2") 
    // console.log(1 + +"1");
    // console.log(1 + "1");
    // console.log("1" + "1" - 1);
    // console.log("1" + "1" + 1);
    // console.log("2" > "12"); //in lexicographical order ,The comparison starts with the first characters of the two strings: "2" and "1".
    // console.log("2" > "32");
    // console.log(2 > 12);
    // console.log("2" > 12);
    // console.log(String([1, 2, 3])); //to convert array to string //String([1,2,3]) → calls [1,2,3].toString() → which returns "1,2,3"
    // console.log(...[1, 2, 3]); //It does not convert the array to a string — it unpacks its items. //Logs them as individual arguments
    // console.log([1,2,3].toString());
    // console.log(1+ [1,2,3]);    //Array to string conversion ; [1, 2, 3].toString() → "1,2,3" //String(1) + "1,2,3" → "1" + "1,2,3" → "11,2,3"
    // console.log("17"+ [1,2,3]);
    // const ab = [1, 2, 3].join('') //becomes string
    // console.log(ab,typeof ab);
    // console.log(1 + [1, 2, 3].join(''))
    // console.log([1,2,3] + [4,5,6]);     //+ operator with arrays, it performs array-to-string
    // console.log(!true-true);
    // console.log(true + "10");    //Boolean to string
    // console.log(true + 10);      //Boolean to number
    // console.log(true + +"10");

    // NOTE : sort and splice affects main/orignal array(fill,reverse also)
    // null : It is often used as a placeholder or to indicate that a variable or property has no assigned value.
    // let variable=null;
    // console.log(variable);
    // undefined : is a primitive datatype that is automatically assigned to variables that has been declared but not initialized any value.
    // let variable;
    // console.log(variable);

    // 1. Operations in javascript are performed from left to right
    // 2. If we add + sign in front of string(+"8") it become number
    // 3. delete return true or false;it only deletes(key value) property not obj.
    // 4. if we delete Array index then it deletes it and write empty there
    // 5. Set removes duplicay from array [...new Set(array)]
    // 6. a=[] ...a makes array element out removing , (array to string conversion)
    // console.log(...[1,2]);
    // console.log([1,2].toString());
    // const a=[1,2,3] // {...a} makes array of object with index as keys
    // console.log({...a});
    // console.log({a});

    // console.log(1+[1,2]);
    // console.log("1"+[1,2]);
    // 11. spread before array func(...[1,2]) converts it into string
    // console.log([..."anil"]);                 //it will break string and make it an array of string
    // console.log(..."anil");           //it make character out of string seperately
    // console.log(...['anil','hi']);
    // console.log(['anil','hi'].toString())
    // 7. ex=true || false && false;
    // console.log(true || true && console.log("1"));
    // console.log(true || true && 10);
    // 8. bCondition1 && bCondition2 is same !(!bCondition1 || !bCondition2)
    // console.log(A || B);                     // true
    // console.log(!(!A && !B));
    // 9. FALSE  =  null ; NaN ; 0 ; empty string ("" or '' or ``) ; undefined.
    // console.log(Boolean({}))
    // 10. nullish operator (??) returns its right-hand side operand when its left-hand
    //  side operand is null or undefined, and otherwise returns its left-hand side operand.
    // 12.During event propagation, there are 3 phases: capturing, target, and bubbling.The deepest
    //  nested element that caused the event is the target of the event.
    //  You can stop bubbling by event.stopPropagation.
    // NOTE:If we click p, we see two logs: p and div.
    // NOTE:typeof null returns "object"
    // 13. here are 8 falsy values: undefined, null, NaN, false, '' (empty string), 0, -0, 0n (BigInt(0))
    // 14. Primitive types are boolean, null, undefined, bigint, number, string, and symbol.
    // 15. 15/2 = Q:7
    // 16. 15%2 = R:1
    // 17. += concatinate and assign
    // >=
    // console.log(3+4+'6');
    // console.log(typeof 3+4+'6');        //o/p are performed from left to right,   'number' + 4 + '6'
    // console.log(typeof (3+4+'6'));    //The parentheses (3 + 4 + '6') force the expression inside to be evaluated first
    // let data = 3 + 4 + "5";
    // console.log(data);
    // console.log(typeof data);

    // let abs = { name: "ritik", age: 12, skill: "rosk" };
    // console.log([abs]);
    // console.log(...[abs]);
    // console.log(...abs);      //Spread syntax requires ...iterable
    // console.log("hi" || (false && false));   //  return true

    // let abs = [{ name: "ritik" }, { age: 12 }, { skill: "rosk" }];
    // console.log(...[abs]);
    // console.log([...abs]);
    // console.log(...abs);
    // console.log({ abs });
    // console.log([ abs ]);

    // const mySet = new Set();

    // mySet.add(1);
    // mySet.add(2);
    // mySet.add(2); // duplicate, ignored
    // console.log(mySet); // Set(2) {1, 2}
    // console.log([...mySet]);

    // let arr=["js","react","vscode"]
    // let arr = [1, 7, 2, 6, 3, 4];
    // const arrs=arr.push("c#","234")      //pushed item in last of array
    // console.log(arrs);    //gives count on no of elements
    // const arrs = arr.unshift("c++","123")      //pushed item in first of array
    // const arrs = arr.pop()              //delete item in last of array and returns that deleted item
    // const arrs = arr.shift()              //delete item in first of array and returns that deleted item
    // const arrs = arr.splice(1,1)
    // const arrs = arr.fill(1)               //fill every element with one
    // const arrs=arr.reverse()               //reverse array
    // console.log(arrs);    //gives reversed array
    // let newArr = arr.map((item) => item * 2); //returns new array with updated values and doesn't affect previous array
    // let newArr=arr.includes(1);        //returns true or false if condition matches
    // let newArr = arr.filter((item,index,array) => {   //return true condition only
    // console.log(item);
    // console.log(index);
    // console.log(array);
    // return item !== 2
    // }); //returns new array with filtered values, it removes the element whose condition becomes false
    // let newArr = arr.filter((item) => item === 2); //if condition is true it takes it out that item
    // let newArr=arr.find((item)=>item>2);     //returns only(7) first array value after condition matches
    // let newArr = arr.some((item) => item > 3); //returns true if either one codition satisfies
    // let newArr = arr.every((item) => item > 3); //returns true when all the codition satisfies i.e, all items must be greater than 3
    // let newArr = arr.findIndex((item) => item === 3); //returns index if condition matches if not matches returns (-1)
    // const fruits = ["apple", "banana", "orange", "banana", "grape"];
    // const bananaIndex = fruits.indexOf("banana");
    // console.log(bananaIndex);
    // let newArr = arr.reduce((prev, curr) => {
    //   //prev is what what you give in dependency
    //   console.log("prev", prev);
    //   console.log("curr", curr);
    //   return prev + curr;
    // }, 0); //gives sum of all numbers

    // let newArr = arr.reduce((x,y)=>x+y,0);
    // console.log(arr);
    

    // const arr = [10, 20, 30, 40, 50];
    // function sumAll(data){
    //   let sum = 0
    //   for (let i = 0; i < data.length; i++) {
    //     sum = data[i] + sum
    //   }
    //   // data.forEach(element => {
    //   //   sum+=element
    //   // });
    //   return sum
    // }

    // console.log(sumAll(arr));

    // let newArr = arr.reduce((prev, curr) => {
    //   return prev + curr;
    // }, 0); //gives sum of all numbers

    // initially prev is 0 and curr[0] is 1 then prev is added value and prev is 1,initialValue is 0

    // function ssuumm(data) {
    //   let sum = 0;
    //   data.forEach((element) => {
    //     sum += element;
    //   });
    //   return sum;
    // }

    // function ssuumm() {
    //   let s = 0;
    //   arr.forEach((ele) => (s += ele));
    //   return s
    // }

    // console.log(ssuumm(arr));

    // function sum(data){
    //   let s = 0;
    //   data.forEach(element => {
    //     s += element
    //   });
    //   console.log("s",s);
    //   return s
    // }

    // console.log(sum(arr));

    // let newArr = arr.join("+");       //convert array into string with + seperated
    // let newArr = arr.toString();          //convert array into string with , seperated
    // console.log(...arr);    //make array elements out w/o , seperation
    // console.log("hello", ...arr.join("/"));      //iterates without , seperation
    // console.log("hello", arr.join("/"));
    // const newArr = arr.splice(3, 0, "i", "p"); //add 2(inclusive) no on 3nd index and dont' remove any ahead elemnet
    // let newArr=arr.slice(0,3);  //Slice from the 1st element to the 3rd element (non-inclusive means delete 3rd index also):         //deletes array element of given index  (Extract elements from index 0 (inclusive) to index 3 (exclusive))
    // let newArr=arr.slice(1,3);    //Slice from the 2nd element to the 4th element (non-inclusive 1 and delete ahead indexes inclusive 3):
    // let newArr=arr.sort();          //sort no alphabetically;; affect main arr
    // let newArr=arr.sort().reverse();          //sort no alphabetically;; affect main arr
    // console.log("newArr", newArr);
    // console.log("arr", arr);

    //extract a section of an array and return a new array.(SLICE) It doesn't modify the orignal array
    // NOTE:If the start index is greater than or equal to the end index, it returns an empty array.
    // var originalArray = [1, 2, 3, 4, 5];
    // var portion = originalArray.slice();
    // var portion = originalArray.slice(6, 3);
    // var portion = originalArray.slice(4, 3);
    // var portion = originalArray.slice(3, 3);
    // var portion = originalArray.slice(1, 14);
    // var portion = originalArray.slice(3, 1);    //as start index is greater than end index
    // var portion = originalArray.slice(1, 4); //This extracts elements from index 1 to (4-1) = 3. The resulting portion array will be [2, 3, 4].
    // var portion = originalArray.slice(2, 4);      //4-1 means 3rd index
    // var portion = originalArray.slice(0, 4);      //array will include elements from index 0 to 4 - 1 = 3, resulting in [1, 2, 3, 4].
    // var portion = originalArray.slice(2);       //This extracts elements starting from index 2 to the end of the array. The resulting copyToEnd array will be [3, 4, 5].
    // var portion = originalArray.slice(-4);        // (-3-1 = 2index) This extracts the last three elements of the array, regardless of the array's length.
    // var portion = originalArray.slice(-3,4);
    // var portion = originalArray.slice(-3,-1);
    // var portion = originalArray.slice(-3,-4);
    // var portion = originalArray.slice(-3,-2);
    // var portion = originalArray.slice(-1,-3);
    // console.log("originalArray", originalArray);
    // console.log("portion", portion);

    //(SPLICE)It modifies the array it's called on and (laster no - 1)
    //  **returns an array containing the deleted elements;
    // return empty [] array with added values
    // var array = [1, 2, 3, 4, 5, 6, 2];
    // var removed = array.splice(2, 2); //removes two elements starting from index 2(start from index inclusive means delete it also).
    // var addArr = array.splice(2, 0, 6, 7);    //inserts 6 and 7 at index 2(start from index inclusive means add at it place also) without removing any elements.
    // var removed = array.splice(0, 2);     //(2-1=1index)start from index 0 and remove elements upto 2 index(non inclusive means don't delete second index element)
    // var removed = array.splice(-2);     //When you use a negative index with splice, it starts counting from the end of the array. In this case, -1 refers to the last element, and -2 refers to the second-to-last element
    // var removed = array.splice(-3, 2);
    // (-2-1=1index)starting from last index to -2 index means delete elements from last index to -2 index(not - inclusive means don't delete -2 index element)
    // var removed = array.splice(2, 1, 'a');       //add a and b
    // var removed = array.splice(2, 0, 'a');
    // var adding = array.splice(array.length, 0, 6, 7); //add 6 and 7 at the last of array
    // var adding = array.splice(100, 0, 6, 7); //add 6 and 7 at the last of array
    // console.log("array", array); //it is modified array,array is now [1, 2, 5]
    // console.log("addArr", addArr); //it gives deleted values,removed is [3, 4]
    // console.log("removed", removed); //adding array element give empty array
    // console.log("adding", adding);
    // console.log("array", array);

    // let arr = [1, 2, 3, 4]; //returns (undefined )it doesn't give new array instead it modifies the orignal array
    // const newArr = arr.forEach((element, index, array) => {
    //   //not need to return anything as we are manipulating array elements
    //   console.log("element", element); //array elements
    //   console.log("%cindex","color:blue", index);
    //   console.log("array", array); //full array arr changes again and again

    //   array[index] = element * 2;
    //   return "true"
    // });
    // console.log(arr);
    // console.log(newArr);

    // NOte :: Saving in other variable gives you deleted things

    // let a = ["1", "2", "3", "4"];
    // let b = ["6", "7", "3", "2"];

    // const combinedObj = [...a,...b];
    // const filtedered  = combinedObj.filter((item,index)=>{
    //   console.log("item",item);
    //   return combinedObj.indexOf(item)===index
    // });
    // console.log(filtedered);
    

    // const fil = a.concat(b.filter((item)=>!a.includes(item)))
    // console.log("fil",fil);

    // const sds= a.concat(b.filter((item,index)=>!a.includes(item)));
    // const sds = b.filter((it,ind)=>!a.includes(it));
    // console.log("sds",sds);

    // const c = a.concat(b);
    // console.log("c",c);
    // const daata = c.filter((item,index)=>c.indexOf(item)===index);
    // const daata = c.filter((item,index)=>b.includes(item));
    // console.log(daata);

    // const c = [...a, ...b];
    // const arr = c.filter((it, index) => c.indexOf(it) === index);
    // console.log("arr", arr);

    // console.log([...new Set(c)]);
    // const ff = a.concat(b.filter((item, index) => !a.includes(item)));
    // console.log("ff", ff);

    // const arr = c.filter((item, ind) => c.indexOf(item) === ind);
    // console.log(arr);
    // const filtt = a.concat(b.filter((item) => !a.includes(item)));
    // console.log("filtt", filtt);

    // const arrs = [1, 2, 3, 4, 5, 7, 2, 1, 5];
    // const ff = arrs.filter(
    //   // (item, index) => arrs.findIndex((it) => it === item) === index
    //   (item, index) => arrs.indexOf(item) === index
    // );
    // console.log("ff", ff);

    // const ff = arrs.filter((item, index) => arrs.indexOf(item)===index);
    // const ff = arrs.filter(
    //   (item, index) => arrs.findIndex((it) => it === item) === index
    // );

    // console.log("ff", ff);

    //   const arr = b.filter((it)=>!a.includes(it));
    //   console.log("arr",a.concat(arr));

    //  const total = [...a, ...b];
    // console.log("total", total);
    // console.log(new Set(total)); //it gives an obj
    // //  console.log(new Set(total)); //spreading obj remove , and give element
    //  console.log([...new Set(total)]); //is to make array

    // let mergedUnique = a.concat(b.filter(item => !a.includes(item)));
    // console.log("Merged Array with Unique Values:", mergedUnique);
    // let mergedUnique = [...new Set([...a, ...b])];
    // console.log("Merged Array with Unique Values:", mergedUnique);

    //  result = "foo" && 4; // result is assigned 4, if both true it returns right side
    //  result = "" && "foo"; // result is assigned "" (empty string)
    //  result = "foo" && "";
    //  a8 = "Cat" && "Dog"; // t && t returns "Dog";both true returns right side
    //  a8 = "" && false; // both false returns "" , returns left side
    //  a8 = false && "";
    // let result = "foo"  || 4;          // result is assigned 4, if both true it returns right side
    //  result = "" || "foo";          // result is assigned foo
    //  result = "foo" && "";      // result is assigned "" (empty string)
    //  a8 = "Cat" || "Dog";           // t && t returns "Dog";both true returns right side
    //  a8 = false || null;        	    //return right side if both false
    //  a8= false || '' || null;
    //  console.log("a8",a8);
    //  console.log( "result",result);
        // console.log(+[1,2,3]);
        // console.log(+{});
    // console.log(5 + !5); // 5 + false → 5 + 0 = 5
    // console.log(5 + !0); // 5 + true  → 5 + 1 = 6
    // console.log([] + []);         // "" → empty string
    // console.log([] + {});         // "[object Object]"
    // console.log({} + []);

    // const foo = (null) ?? "default string"; //if 1st condition is null or undefined it returns right side
    // console.log(foo); //else it returns left condition

    // const baz = 0 ?? 42;      //as 0 is not null or undefined
    // console.log(baz);

    // function getAge(...args) {
    //   console.log(args); //spread operator makes it an array
    //   console.log(...args);
    //   console.log(typeof args); //type of arguement is object
    // }
    // getAge(21);

    // for (var i = 0; i < 3; i++) {        //it only updates one key, captures the variable i by reference
    //   console.log(i);
    //   setTimeout(() => console.log(i), 2000);
    // }

    // now it's in global scope and behaves like var
    
    // for (let i = 0; i < 3; i++) {     //it creates 3 lets
    //   console.log(i);
    //   setTimeout(() => console.log(i), 1);
    // }

    // let radius = 11;
    // const shape = {
    //   radius: 10,
    //   diameter() {
    //     // return radius * 1;
    //     return this.radius * 2; //with regular function this keyword refers to its current surrounding scope,
    //   }, //example shape object
    //   perimeter: () => 2 * radius, //fat arrow fun doesn't refer to the shape object,it's
    // }; //surrounding scope is window for example
    // they inherit the this value from the enclosing function or context but it's a object.
    // , it doesn't refer to the shape object's radius, but rather it refers to the radius variable in the outer scope

    // console.log(shape.diameter());
    // console.log(shape.perimeter());

    // Getting key from OBJECT by DOT method and by ARRAY Method
    // const bird = {
    //   size: "small",
    // };

    // const propertyName = "size";
    // console.log(bird[propertyName]); // Accessing the property using a variable
    // console.log(bird.propertyName); //undefined

    // const book = {
    //   "title with spaces": "JavaScript Guide",
    //   "year published": 2022,
    // };

    // console.log(book["title with spaces"]); // Output: JavaScript Guide
    // console.log(book.title with spaces);

    // const bird = {
    //   size: "small",
    // };
    // const mouse = {
    //   name: "Mickey",
    //   small: true,
    // };

    // console.log(mouse[bird.size]);
    // console.log(mouse[bird["size"]]);

    // let c = { greeting: "Hey!" };
    // let d;
    // d = c;
    // console.log(d === c);
    // c.greeting = "Hello"; //you change one object, you change all of them
    // console.log(d.greeting); //as c and d have same reference

    // console.log(new Number(3) == 3); //it's an object whose value is 3
    // console.log(typeof new Number(3));

    // function getPersonInfo(one, two, three) {
    //   console.log(one); //tagged template literals, the value of the first argument is                                    // always an array of the string of empty values
    //   console.log(two); //The remaining arguments get the values of the passed expressions
    //   console.log(three);
    // }
    // const person = "Lydia";
    // const age = 21;
    // getPersonInfo`Mr. ${person} is only ${age} years old`;

    // function checkAge(data) {
    //   if (data === { age: 18 }) {
    //     //The two objects that we are comparing don't have tha
    //     console.log("You are an adult!"); //t: the object we passed as a parameter refers to a different location in memory
    //   } else if (data == { age: 18 }) {
    //     console.log("You are still an adult.");
    //   } else {
    //     console.log(`Hmm.. You don't have an age I guess`);
    //   }
    // }
    // checkAge({ age: 18 });

    // function getAge(...args) {
    //   console.log(args);
    //   console.log(...args);
    //   console.log(typeof args);
    //   console.log(typeof []);
    // }
    // getAge(21);

    // function getAge(...args) {
    //   console.log(args);
    //   console.log(...args);
    //   console.log(typeof args);
    //   console.log(typeof []);
    // }
    // getAge([21,22]);

    // let a=[];
    // let b=[];
    // console.log(a==b);     //when we compare 2 array it actually compare its memory location
    // console.log(a===b);

    // let a=[];
    // let b=a;
    // console.log(a==b);
    // console.log(a===b);

    // let a=[20];
    // let b=[20];
    // console.log(a[0]==b[0]);       //we specified element so value will be compared
    // console.log(a[0]===b[0]);

    // let z = [1, "hgcv", 2, 3, 4];
    // let a = { name: "ritik" };
    // console.log(z);
    // console.log(...z); //it breaks array,object into its elements

    // let a="hi"
    // console.log(typeof a/5);       //Nan
    // console.log(typeof 3/a);       //Nan

    // console.log(typeof NaN);        //NaN is obtain when we divide non-numeric value like string,obj etc

    // let data=10 - -10;              //mathematics rule
    // console.log('data',data);

    // const set = [...new Set([1, 2, 3, 1, 2, 3, 4, 5, "hi", "bingo", "dd", "hi"])]; //set removes duplicacy of elements
    // console.log(set);

    // let a=["1","2","3","4"]
    // let b=["6","7","3","2"]
    // const arr=[...a,...b]
    // const c = arr.filter((it,index)=>!a.includes(it));
    // console.log(c);

    // const uniqueArr = a.concat(b.filter((item)=>!a.includes(item)));
    // console.log(uniqueArr);
    
    // const arr=[...a,...b]
    // console.log([...new Set(arr)]);
    // const ab=a.filter((it)=>b.includes(it))
    // console.log(ab);

    // let data = { name: "anil", age: 98 };
    // console.log(data);
    // console.log(delete data.name); //it returns trur or false ; wew can delete key-value by giving key name
    // console.log(data); //after deleting data is an empty {}
    // console.log(delete data); //we can delete property of data but not data object**

    // let data = ["anil", "peter", "bruce", "lee"];
    // const tt = delete data[1];
    // console.log(tt);
    // console.log(data);
    
    // //                  //it deletes (index with value) peter and write empty there
    // console.log(data?.length);

    // const data = ["Hi", "hello", "king"];
    // const [y, z] = data; //ARRAY DESTRUCTURING gives first value of array element
    // console.log(y, z);
    // const [, , a] = data; //gives first arrray index value of array element [1]
    // console.log("a : ", a); //without z wanted to get 2nd value

    // let a = { name: "ritik", age: 12, saill: "rosk" };
    // let b = { school: "gbsss", saill: "rk" };     //merge 2 objects
    // console.log(...[a]);
    // let c = { ...a, ...b };
    // console.log(c);                             //if we have skill common in both objects we get saill key
    // c = { a, ...b };                             // of upper object and value of lower object
    // console.log(c);

    // a = 10;
    // console.log(typeof a); //Variable hoisting
    // console.log(a);
    // var a;
    // let a;

//     sayHello(); // ✅ Works
// function sayHello() {
//   console.log("Hello!");
// }
//Function declarations are fully hoisted — their entire body is moved to the top.
//hence, you can call them before their definition

//     console.log(sayHi); // ❌ TypeError
// var sayHi = function() {
//   console.log("Hi!");
// };

// Only the variable sayHi is hoisted (initialized as undefined).
// The function value is assigned later — so calling it early fails.

    // let a = [1, 2, 3, 4, 5];
    // let b = [4, 5, 6];
    // console.log(...a);                         //it doen't replace
    // let c = [...a, ...b]; //it takes both 4 in the array
    // console.log(c);
    // console.log([...new Set(c)]);

    // const a = [1, 2, 3, 4, 5, 4, 5, 6];
    
    // const tt = a.filter((item,index)=>a.indexOf(item)===index);
    // const tt = a.filter((item,index)=>a.findIndex((it)=>it===item)===index);
    // console.log("tt",tt);
    

    // const resp = a.filter((value, index, self) => {
    //   console.log("value", value);
    //   console.log("index", index);
    //   console.log("self", self); //it is used to take orignal array
    //   console.log(self.findIndex((it)=>console.log(it)));
    //   console.log(self.findIndex((it)=>it===value));
    //   console.log("self.indexOf(value)", self.indexOf(value));
      // return self.findIndex((it)=>it===value) === index;
      // return self.indexOf(value) === index; //index of gives index of value
    // });
    // console.log("resp", resp);

    // let a = [1, 2, 3];
    // let b = [4, 5, 6];
    // let c = [...a, ...b]; //it merges 2 array
    // let d = { ...a }; //it makes array an object with index as keys
    // console.log(c);
    // console.log(...b); //make array elements out from array
    // console.log(d);

    // const result=false || {} || null;               //prints obj bcoz it's +ve and true value
    // const result1=false || '' || null;              //it picks last entry bcoz all 3 are false
    // console.log(result);
    // console.log(result1);

    // let name = "sidhu"; //let has block level scope & it can't pursue variable hoisting
    // function getName() {
    //   let name = "jk";
    //   console.log(name); //local variable & global variable
    //   // let name="pal";
    // }
    // getName();

    // console.log(`${(x=>x)('I love')} to program`);

    // function sumValues(x, y, z) {
    //   console.log("x : ",x);
    //   console.log("y : ",y);
    //   console.log("z : ",z);

    //   return x + y + z;
    // }
    // console.log(sumValues(1, 5, 3)); //spread before array func(...[1,2]) converts it into string
    // console.log(...[1, 5, 3]);
    // console.log(sumValues(...[1, 5, 3]));

        // const name = "code";
        // console.log(typeof name); //name is not empty string so it's true, ! makes it false
        // console.log(!typeof name); //& when false it compared with (not empty string) it
        // console.log(!typeof name === "object"); //returns false false === "object" → false
        // console.log(!typeof name === "string");     //false === "string" → false
        // console.log(typeof false);
        // console.log(typeof name !== "object"); // true
    // console.log(typeof name !== "string"); // false

    // let person = { name: "anil" };
    // console.log(person);
    // person.age = 30;
    // console.log(person);
    // //add new key in object
    // Object.seal(person); //after applying seal we cann't add new key but can modify person
    // console.log(person);
    // person.name = "king"; //cann't add new key but can modify the name key
    // person.class = "hello";
    // console.log(person);

    // const data = [2, 4, 5, 6, 0];
    // let string = "Hi this is Ritik";
    // let sp = string.split(" ");
    // console.log(sp);
    // let dele = data?.splice(0, 1);     //modifies orignal array
    // console.log(dele);
    // console.log(data);
    // let del = data?.slice(0, 1);        //gives new array
    // console.log(del);
    // console.log(data);
    // let shift = data?.shift(0,3);
    // console.log(shift);
    
    // console.log(data?.shift());
    // console.log("Removed array element", shift);
    // console.log("All rest array elements", data);

    // const data="true";
    // console.log(Boolean(data));                     //convert string to boolean
    // console.log(typeof !!data);

    // let a = 2;
    // setTimeout(() => {
    //   console.log(a);
    // }, 0); //it runs st before that the
    // a = 100; //value of a already become 100

    // let a = 1;
    // let b = 1;
    // let c = 2;
    // console.log(a === c--);
    // console.log(a === --c); //-- decrement happens so c=1 and returns true
    // console.log((a === b) === --c); //a===b is true and now boolean is compared to number

    // console.log([[[[]]]]);   //3 array element has length 1 and 4th have length 0

    // (Important)
    // function fruit() {
    //   name="apple";               //give value here
    //   console.log(name);
    //   var name = "apple12345"; //var gets hoisted with the default value of undefined
    //   let price = 20;
    // }
    // fruit();

    // for (var i = 0; i < 3; i++) {
    //   setTimeout(() => {
    //     //setTimeout etc mover in a stack of our code & runs at the end
    //     console.log(i); //var is decalared globally
    //   }, 1000);
    // }

    // let data = "size";
    // const bird = {
    //   size: "small",
    // };
    // console.log([data]); //so same case like log 2
    // console.log(bird[data]); //when we have to use var with object then obj[]
    // console.log(bird["size"]);
    // console.log(bird.size);
    // console.log(bird.data);     //undefined

    // let c = { name: "anil" };
    // let d;
    // d = c;
    // c.name = "kumar"; //we get latest value as memory loc of c and d are same
    // console.log(d.name);

    // let a = 3;
    // let b = new Number(3);
    // console.log(new Number(3)); //it's an object but it's value is 3
    // console.log(a == b);
    // console.log(a === b);

    // function sum(x, y) {
    //   return x + y;
    // }
    // console.log(sum(1, "2"));
    // console.log(sum(1, 2));

    // let number = 0;
    // console.log(number++); //post increment it prints 0 but the value become 1
    // console.log(++number); //pre increment value become 2 then printed
    // console.log(number);

    // function getAge(...args) {
    //   //spread operator makes it an array
    //   console.log(...args);
    //   console.log(typeof args); //type of arguement is undefined
    // }
    // getAge(21);

    // function getAge(...args){
    //     // 'use strict';                            //but use-strict says follow rules strictly,no hoisting etc
    //     let age = 21;                                 //whenever we don't define let,var etc it auto takes it var
    //     console.log(age);
    // }
    // getAge(21);

    // const sum = eval(10 * 10 + 5 - 2); //eval does the mathematical calculations
    // console.log(sum);

    // const obj = { cat: "one", bat: "two", cat: "repeat" }; //prints key of first a and value of second a
    // console.log(obj);

    // for (let i = 0; i < 5; i++) {
    //   if (i === 3) {
    //     continue; //continue will not print rest code when the condition matches
    //   }
    //   console.log("I",i);
    // }

    // const person = { name: "anil" };
    // function sayHi(age) {
    //   // console.log(age);
    //   return `${this.name} is ${age}`;
    // }
    // console.log(sayHi.call(person, 21)); //it's called on it's own no callback is required
    // console.log(sayHi.bind(person, 21)); //returns function as it is with added properties
    // console.log(sayHi.bind(person, 21)()); //callback is required,bind is called manually
    // console.log(sayHi.apply(person, [21]))

    // ***
    // function sayHello(){
    // return(()=>0);                      //it returns a function
    // return(()=>0)();                    //it returns a zero as fat arrow fun is called
    // }
    // console.log(sayHello());
    // console.log(sayHello()());
    // console.log(typeof sayHello());
    // console.log(typeof sayHello()());           //it also returna a number

    // console.log(typeof typeof 1);        //typeof 1 is number & number is a string which is a string

    // const numbers = [1, 2, 3];
    // numbers[6] = 11; //index 3,4,5 become empty
    // console.log(numbers);
    // console.log(numbers.length);
    

    // const numbers = [1, 2, 3];
    // numbers[6] = numbers; //everytime at 6th index it pushes an array
    // console.log(numbers);

    // console.log(!!null);
    // console.log(!!"");
    // console.log(!!1);

    // console.log([..."anil"]);                 //it will break string and make it an array of string
    // console.log(..."anil");           //it make character out of string seperately
    // console.log(...['anil','hi']);    //it make word come out

    // // **Imp
    // let person={name:'anil'}        //mem loc. of obj and array is diff. so
    // const member=[person];          //when we null object it doesn't null the array
    // person=null;
    // console.log(member);
    // console.log(person);            //makes person null object

    // let data = 3 + 4 + "5";
    // console.log(data);
    // console.log(typeof data);

    // ***
    // console.log(typeof typeof false);
    // console.log(typeof 3+4+'6');        //o/p are performed from left to right,type of 3 is number+46
    // console.log(typeof (3+4+'6'));
    // console.log(typeof (3+4+ +'6'));        //if we add + sign in front of string(+"8") it become number

    // const a = [];
    // let b = a;
    // console.log(a === b);
    // console.log([] == []); //memory loc of both the array's is different

    // let data=[1,2,3].map((item)=>{
    //   console.log(typeof item==='number');
    //     // if(typeof item==='number') return;    //as it's not returning anything so it returns undefined
    //     return item*2;
    // });
    // console.log(data);

    // **Imp
    // function getInfo(member) {
    //   console.log(member); //memeber is obj inside member name key is modified
    //   member.name = "singh";
    // }
    // const person = { name: "Ritik" }; //when we pass object in a function call by refernce works
    // getInfo(person); //and when we changes it in function it auto changes in person obj
    // console.log(person); //due to same reference

    // (() => {
    //   let x = (y = 10); //undefined because x have block level scope
    //   console.log(x,y);
    // })(); //fat arrow function is called
    // console.log(typeof x);

    // (() => {        //Immediately Invoked Function Expression
    // //  (IIFE)
    //   // var y;
    //   let x = (y = 10); //bcoz it's like let x=10,var y=10 & var has global scope
    //   console.log(x,y);
    // })(); //so y is accessible outside
    // console.log(typeof y);

    // (() => {
    //   var x = (y = 10); // var x makes it a block level scope while y is global scope
    // })();
    // console.log(typeof x);
    // // console.log("x : ", x);
    // console.log(typeof y);

    // let x = 100;
    // (() => {
    //   var x = 20; //now it act's as block bcoz x is already declared outside
    // })(); //so y is accessible outside
    // console.log(x);

    // console.log(!true-true);        //true=1 !true=0 so 0-1=-1

    // 1+10(number bcoz string is converted to number by + before string)

    // STRING QUESTIONS

    // let str = "Hello, How are you?";

    //1.Convert string in only one array

    // console.log([str]);
    // console.log(str.split())       //makes strin a array
    // console.log(str.split(""));           //give array of each characters
    // console.log(str.split(" "));         //give array of characters

    //2.Convert string to array with each character
    // console.log(...str);
    // console.log([...str]);  //same as str.split("")

    //3.Convert string to array on the basis of a chacter
    // console.log(str.split('a'));

    //4.replace any chacter
    // console.log(str.replace('H','W'));      //works on single character
    // console.log(str.replace(/H/g,'W'));     //works for all characters

    // 5.get string from subString
    // console.log(str.substring(0,1));

    //6.Remove first character from string
    // console.log(str.substring(0,str.length));

    // 7.reverse a string
    // console.log(str.split("").reverse().join(""));    //array can be reversed not string

    // 8.Remove empty spaces
    // console.log(str.trim());

    // 9.Concat two string
    // let a="hello";
    // let b="Candidate"
    // let c= a+' ' +b
    // console.log(String(c));

    // const b = [1, 2, 3];
    // console.log("b", b.push(4));
    // console.log("b", b);

    // ARRAY QUESTIONS

    // let data = [2, 4, 6, 3, 7, 3, 6, 4, 9, 5];

    // console.log(data.reduce((x,y)=>x+y));

    // function ss(payload){
    //   let sum = 0
    //   payload.forEach(element => {
    //     sum += element
    //   });
    //   return sum
    // }
    // console.log(ss(data));
    
    // 1.Find sum of all array elements
    // let sum = data.reduce((x, y) => x + y, 0);
    // console.log(sum);

    // let x =  10;  //assignment statement in JavaScript that uses the comma operator to evaluate multiple expressions and assign the result of the last expression to the variable x
    // x = (x++, x); //first perform action second prints the outcome
    // x = ((x += 10), x);
    // x = ((x += 10), 6);
    // x = ((x += 10), 6); //, 6 is a comma operator that evaluates expressions from left to right and returns the value of the last expression, which is 6.
    // console.log(x);

    // CLOSURES
    //a closure gives you access to an outer function's scope from an inner function
    // even after the outer function has finished executing..

    // const teacher = () =>{
    //   let x = 10

    //   return function innerFunc(arg){
    //     return arg+x
    //   }
    // }

    // const tt = teacher();
    // console.log(tt);
    // console.log(tt(5));

    // const closuress =()=>{
    //   let x = 10
    //   console.log("Outer Function");

    //   return function innerFunc(){
    //     console.log("Inner Function")
    //     return x+12
    //   }
    // }

    // console.log(closuress()());

    // function outer(){
    //   let x = 10;
    //   return function inner(){
    //     return x
    //   }
    // }

    // const outerFunc=()=>{
    //   let num = 10
    //   return function innerFunc(){
    //     return num;
    //   }
    // }

    // console.log(outerFunc()());

    // console.log(outer()());

    // function outer(){
    //   const num = 10;
    //   console.log("outer function");
    //   return function inner(){
    //     console.log("num",num);
    //     console.log("inner Function");
    //   }
    // }

    // function outFunc() {
    //   const ab = 10;
    //   return function innerfunc() {
    //     console.log(ab);
    //   };
    // }

    // const closure = outFunc();
    // console.log(closure());

    // function outFunc(){
    //   const a = 8
    //   console.log("OUter Called",a);
    //   return function innerFunc(){
    //     let b = 3;
    //     console.log("inner called ",a + b);
    //     return a + b
    //   }
    // }

    // console.log(outFunc()());

    // console.log(outer()());

    // function out(){
    //   console.log("out");
    //   const a = 10

    //  return function iner(){
    //     console.log("iner",a);
    //   }
    // }

    // console.log(out()());
    // function outerFunction(outerVariable) {
    //   console.log("outerVariable", outerVariable);
    //   // This is the inner function, which is a closure (LEXICAL SCOPING)
    //   function innerFunction(innerVariable) {
    //     console.log("innerVariable", innerVariable);
    //     console.log(outerVariable + innerVariable);
    //   }

    //   // Return the inner function
    //   return innerFunction || "No Paraeter passes";
    // }
    // outerFunction(12)(13);

    // Create a closure by calling outerFunction
    // const closure = outerFunction(10);
    // console.log("closure",closure);     //When we call outerFunction(10), it returns the innerFunction, creating a closure.
    // //The innerFunction now has access to the outerVariable, even though outerFunction has finished executing.
    // // Use the closure
    // closure(5); // Outputs: 15

    // function x(){
    //   const a=7;
    //   function y(){
    //     console.log(a);     //lexical scoping
    //   }
    //   y();
    // }
    // console.log("hgf");

    // x();

    //when functions return from their lexical scope they still maintain ther position
    // function x() {
    //   var a = 7;
    //   function y() {
    //     console.log(a); //lexical scoping
    //   }
    //   return y;
    //   // return function y() {
    //   //   console.log(a); //this is same
    //   // };
    // }

    // console.log(x()); //it calls x and get whole y function as value
    // x()();      //same as z
    // var z = x();
    // console.log(z);
    // z();      //now again when z is called it triggers to the same y function

    // function x() {
    //   var a = 7;
    //   function y() {
    //     console.log(a);        //this is same
    //   }
    //   a=100;
    //   return y
    // }
    // x()()

    // function z() {
    //   var b = 900;
    //   function x() {
    //     var a = 7;
    //     function y() {
    //       console.log(a, b); //this is same
    //     }
    //     y();
    //   }
    //   x();
    // }
    // z();

    // function x() {
    //   for (var i = 1; i <= 5; i++) {
    //     function close(i) {
    //       //every time this i creates a new memory refrence
    //       setTimeout(() => {
    //         console.log(i);
    //       }, i * 1000);
    //     }
    //     close(i);
    //     // console.log("Nameste");
    //   }
    // }
    // x();

    //TIMER

    // function startTimer(data) {
    //   for (let index = 0; index <= data; index++) {
    //     setTimeout(() => {
    //       console.log(index);
    //     }, index * 1000);
    //   }
    // }

    // startTimer(5);

    // function timer(data){
    //   for (let i = 0; i < data; i++) {
    //     setTimeout(() => {
    //     console.log(i);
    //   }, 1000 * i);
    //   }
    // }

    // console.log(timer(5));

    //THIS ES6
    // this refers to the object that is calling the function — and its value depends on 
    // how the function is invoked, not where it’s defined.
    //In the global level this points to window object
    //window is global object which is created along with global execution context

//     2 — async / await (syntax sugar over Promises)
// async functions always return a Promise. await pauses execution inside the async
//  function until the awaited Promise resolves (or throws when it rejects).


    // COUNTING OCCURANCIES
    // const fruits = ["apple", "banana", "apple", "orange", "banana", "apple"];
    // const count = fruits.reduce((acc, fruit) => {
    //   acc[fruit] = (acc[fruit] || 0) + 1;
    //   return acc;
    // }, {});
    // console.log(count)

    // function countOccurrences(arr) {
    //   const obj = {};
    //   arr.forEach(item => {
    //     obj[item] = (obj[item] || 0) + 1;
    //   });
    //   return obj;
    // }

    // console.log(countOccurrences(fruits));


    // Grouping by property
      // const people = [
      //   { name: "Ritik", age: 25 },
      //   { name: "Amit", age: 25 },
      //   { name: "Priya", age: 30 }
      // ];

      // const grouped = people.reduce((acc, person) => {
      //   (acc[person.age] = acc[person.age] || []).push(person);
      //   return acc;
      // }, {});

      // console.log(grouped);

      //Prototypal Inheritance : objects can inherit properties and methods from other objects.
      // const person = {
      //   greet() {
      //     console.log(`Hello, I am ${this.name}`);
      //   }
      // };

      // const ritik = Object.create(person); // inherits from person , The prototype relationship is created using Object.create(person).
      // console.log(ritik);   //ritik doesn’t have greet(), so JS looks up in its prototype (person)
      // ritik.name = "Ritik";
      // ritik.greet();

// Mutable Example (Bad Practice)
// const user = { name: "Ritik", age: 28 };
// user.age = 29; // ❌ mutated
// console.log(user);

// // Immutable Example (Good Practice) //Don’t modify original — make new copies
// const user = { name: "Ritik", age: 28 };
// const updatedUser = { ...user, age: 29 }; 
// console.log("updatedUser",updatedUser);
// console.log("user",user);


// const numbers = [1, 2, 3];

// // ❌ Bad: Direct mutation
// const pushedArr = numbers.push(4);
// console.log("pushedArr",pushedArr);
// console.log(numbers);


// // ✅ Good: Create new array
// const newNumbers = [...numbers, 4];
// console.log("newNumbers",newNumbers);
// console.log("numbers",numbers);


    // FLATTING Array
    // var array = [1, 2, 3, [7, 8, [9]], 4, [5], 6];
    // const flat = array.reduce((acc, curr) => acc.concat(curr), []);     //flat array upto 1 level
    // console.log(flat);
    // const recusion = (data)=>{
    //   const emptyArr = []
    //   data.forEach((item)=>{
    //     if(Array.isArray(item)){
    //       emptyArr.push(...recusion(item))
    //     }
    //     else{
    //       emptyArr.push(item)
    //     }
    //   })
    //   console.log("emptyArr",emptyArr);
    //   return emptyArr

    // }

    // console.log(recusion(array));

    // var array = [1, 2, 3, [7, 8, [9]], 4, [5], 6];

    // function flatArr(data){
    //   const emptyArr = []
    //   data.forEach((element) => {
    //     if(Array.isArray(element)){
    //       emptyArr.push(...flatArr(element))
    //     }
    //     else{
    //       emptyArr.push(element)
    //     }
    //   });

    //   return emptyArr
    // }

    // console.log(flatArr(array));

    //   var obj={name:"ritik"}
    // function flattenArray(arr) {
    //   var flattened = [];
    //   console.log("flattened",flattened);
    //   arr.forEach(function (item) {
    //     console.log("item", item);
    //     console.log("isArray", Array.isArray(item));
    //     if (Array.isArray(item)) {
    //       flattened = flattened.concat(flattenArray(item));
    //       console.log("flattenedArray",flattened);
    //     } else {
    //       flattened.push(item);
    //     }
    //   });

    //   return flattened;
    // }
    // var flattenedArray = flattenArray(array);
    // console.log(flattenedArray);

    // PALENDROME
    // const input = window.prompt("Enter name")
    // function isPalen(text){
    //   const strLength = text.length;
    //   for (let i = 0; i < strLength/2; i++) {
    //     if(text[i] !== text[strLength - i - 1]){
    //       return false
    //     }

    //     return true
    //   }
    // }

    // console.log("input",input);

    // const revInput = input.split('').reverse().join('');
    // console.log("revInput",revInput);
    // console.log(input===revInput ? "Palendrome" : "Not Palendrome");

    // console.log(isPalen(input) ? "Palendrome" : "Not Palendrome" );

    // const a = window.prompt("Enter value of a");
    // const straight = a.split('').reverse().join('');
    // console.log(a===straight ? "Palendrome" : "Not Palendrome");

    // console.log("straight",straight);

    // const isPalen=(data)=>{
    //   const strLength = data.length
    //   for (let i = 0; i < strLength/2; i++) {
    //     if(data[i]!==data[strLength - 1 -i]){
    //       return "Not Palendrome";

    //     }
    //   }
    //   return "Palendrome";
    // }

    // console.log(isPalen(a));

    // If first and last chacter are same it's palendrome
    // function checkPalindrome(string) {
    //   console.log("string",string);
    //   console.log("string",string[0]);

    //   const len = string.length;
    //   console.log("len",len);
    //   for (let i = 0; i < len / 2; i++) {
    //     console.log("i : ",i);
    //     console.log("string[i]",string[i]);
    //     console.log("string[len - 1 - i]",string[len - 1 - i]);
    //     if (string[i] !== string[len - 1 - i]) {
    //       return "It is not a palindrome";
    //     }
    //   }
    //   return "It is a palindrome";
    // }
    // const string = prompt("Enter a string: ");
    // const value = checkPalindrome(string);
    // console.log(value);

    //PROMISES
    // AN object there are 3 states of promise object,pending,resolved,rejected
    // resolved .then()
    // rejected .catch()

    // const demoProm1 = new Promise((resolve,rejected)=>{
    //   setTimeout(()=>rejected("Promise 1 is resolved"),1000)
    // });
    // const demoProm2 = new Promise((resolve,rejected)=>{
    //   setTimeout(()=>resolve("Promise 2 is resolved"),200)
    // });
    // const demoProm3 = new Promise((resolve,rejected)=>{
    //   setTimeout(()=>rejected("Promise 3 is resolved"),400)
    // });

    // const resp = Promise.race([demoProm1,demoProm2,demoProm3])
    // .then((resp)=>console.log("resp",resp))
    // .catch((error)=>console.log("error",error))

    // const resp = Promise.all([demoProm1,demoProm2,demoProm3])
    // .then((resp)=>console.log("resp",resp))
    // .catch((error)=>console.log("error",error))

    //  const resp = Promise.any([demoProm1,demoProm2,demoProm3])
    // .then((resp)=>console.log("resp",resp))
    // .catch((error)=>console.log("error",error))

    // const resp = Promise.allSettled([demoProm1,demoProm2,demoProm3])
    // .then((resp)=>console.log("resp",resp))
    // .catch((error)=>console.log("error",error))
    

    // demoProm.then((resp)=>console.log(resp)).catch((err)=>console.log(err))

    // promise.race
    // it return the firstly resolved or rejected promise

    // const pr1 = new Promise((resolve, reject) => {
    //   setTimeout(()=>resolve("Resolve First"),1000)
    // })

    // const pr2 = new Promise((resolve, reject) => {
    //   setTimeout(()=>resolve("Resolve Second"),700)
    // })

    // const pr3 = new Promise((resolve, reject) => {
    //   setTimeout(()=>reject("Error"),400)
    // })

    // const res = Promise.any([pr1,pr2,pr3]).then((resp)=>console.log(resp)
    // ).catch((err)=>console.log(err)
    // )

    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve("one");
    //   }, 500);
    // });

    // const promise2 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve("two");
    //   }, 200);
    // });

    // const promise3 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     reject("It is rejected");
    //   }, 90);
    // });

    // Promise.race([promise1, promise2, promise3])
    //   .then((value) => {
    //     console.log("value", value);
    //   })
    //   .catch((err) => console.log("err", err));

    // promise.all; (All promises should be resolved) [Gives array of values if all promises are resolved and reason if rejected]
    // It takes an iterable of promises as input and returns a new promise
    // that resolves when all the promises in the iterable have resolved successfully. The
    // resolved values of all the promises are collected into an array in the same order as the original promises.
    // It doesn't executes with less sec

    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 1 resolved"), 1000);
    // });

    // const promise2 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 2 resolved"), 500);
    // });

    // const promise3 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 3 resolved"), 800);
    // });

    // Promise.all([promise1, promise2, promise3])
    //   .then((results) => {
    //     console.log("All promises resolved:", results);
    //   })
    //   .catch((error) => {
    //     console.log("One of the promises rejected:", error);
    //   });

    // promise.allsettled()
    // gives array of with status key as fulfilled or rejected and value if resolved and reason if rejected
    // It doesn't executes with less sec
    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 1 resolved"), 1000);
    // });

    // const promise2 = new Promise((resolve, reject) => {
    //   setTimeout(() => reject(new Error("Promise 2 rejected")), 500);
    // });

    // const promise3 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 3 resolved"), 800);
    // });

    // Promise.allSettled([promise1, promise2, promise3]).then((results) => {
    //   console.log("All promises settled:", results);
    // });

    // promise.any
    // run all promises untill any one one of is resolved and returns firstly resolved promise
    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => reject("Promise 1 resolved"), 1000);
    // });

    // const promise2 = new Promise((resolve, reject) => {
    //   setTimeout(() => reject(new Error("Promise 2 rejected")), 500);
    // });

    // const promise3 = new Promise((resolve, reject) => {
    //   setTimeout(() => reject("Promise 3 resolved"), 800);
    // });

    // Promise.any([promise1, promise2, promise3])
    //   .then((result) => {
    //     console.log("At least one promise resolved:", result);
    //   })
    //   .catch((errors) => {
    //     console.log(errors);
    //   });

    // const myPromise = new Promise((resolve, reject) => {
    //   if (false) {
    //     resolve("It is true");
    //   } else {
    //     reject("It is false");
    //   }
    // })
    //   .then((resp) => {
    //     console.log("resp", resp);
    //   })
    //   .catch((err) => {
    //     console.log("err", err);
    //   });

    //   console.log(myPromise);

    // Template String
    // const a = "Ritik";
    // const b = "Chauhan";
    // console.log("Welcome to team " + a + ". Hi " + b + "");
    // console.log(`Welcome to team ${a}. Hi ${b}`);

    // Object Dstructuring
    // const details = {
    //   name: "ritik",
    //   age: 22,
    // };

    // const name = details.name;
    // const age = details.age;
    // console.log(name, age);

    // const { name, age } = details;
    // const { name: companyName, age } = details;

    // console.log(name,age);
    // console.log(companyName,age);

    // Array Dstructuring
    // const arr = ["a", "b", "c", "d"];
    // console.log(arr[3]);

    // const arr = ["a", "b", "c", "d"];
    // const [p, q, r, s] = arr;
    // console.log("p : ", p);

    //SPREAD AND REST
    // const oldArr = [1, 2, 3, 4];
    // console.log(...oldArr);
    // const newArr = [...oldArr, 2, 3, 4];
    // console.log("newArr", newArr);

    // function sum(a, b, ...numbers) {
    //   console.log(a, b);
    //   console.log("numbers", numbers); //it gather all arguements into a single array
    //   return numbers.reduce((total, num) => total + num, 0);
    // }
    // console.log(sum(1, 2, 3, 4, 5));

    //DIfference between normal function and fat-arrow function
    // function add(a, b) {
    //   return a + b; //no implicit return for single statement
    // }

    // const add = (a, b) => a + b; //implicit return for single statement
    // console.log(add(2, 3));

    // var namesq = "111"
    // let obj={
    //   namesq:"ritik",
    //   normaFunc(){
    //     console.log("Normal ",this.namesq);
    //   },
    //   fatArrowFunc:()=>{
    //     console.log("Fat "+ this.namesq);
    //   }
    // }

    // console.log(obj.normaFunc());
    // console.log(obj.fatArrowFunc());

    // let userInfo={
    //   name:"code Improve",
    //   fullName(){
    //     console.log(this.name + "Normal Function");
    //   },
    //   fullName2:()=>{
    //     console.log(this.name + "Fat Function");      //don't have their own this value
    //   }
    // }

    // console.log("this ", this);

    // let userInfo = {
    //   name: "code Improve",
      // fullName() {
      //   const name = () => {
      //     console.log(this.name);
      //     console.log(this.name + "Fat Function");    //lexical scoping it found name in parent
      //   };
      //   name();
      //   console.log(this.name + "Normal Function");
      // },
    //   fullName2: () => {
    //     console.log("this ", this);   //value of this inside a fat-arrow fn is same as otside a fn
    //     console.log(this.name + "Fat Function"); // Arrow functions do not have their own this context. Instead, they capture the value of this from the surrounding scope
    //   },
    // };

    // userInfo.fullName();
    // userInfo.fullName2();

    //Currying:function is transformed into a sequence of functions, each taking a single argument.
    // This curried function works by creating closures that capture each argument one by one until all the necessary arguments have been provided

    // function a(x){
    //   return function b(y){
    //     return function c(z){
    //       return x+y+z
    //     }
    //   }
    // }

    // console.log(a(3)(4)(5));

    // function a(x){
    //   return function b(y){
    //     return function c(z){
    //       return x+y+z
    //     }
    //   }
    // }

    // const func=(x,y,z)=>{
    //   return x+y+z
    // }

    // console.log(a(2)(4)(2));
    // console.log(func(2,4,2));

    // const normalSum = (a,b,c)=>a+b+c
    // console.log(normalSum(2,5,6));
    // function currySumFunc(a){
    //   return function(b){
    //     return function(c){
    //       return a+b+c
    //     }
    //   }
    // }

    // console.log(currySumFunc(1)(2)(3));

    // const multiArgFunction = (a, b, c) => a + b + c;
    // console.log(multiArgFunction(1, 2, 3)); // 6

    // const curryUnaryFunction = (a) => (b) => (c) => a + b + c;
    // function curr(a){
    //   return function(b){
    //     return function(c){
    //       return a+b+c
    //     }
    //   }
    // }

    // console.log(curr(2)(3)(5));

    // function curryUnaryFunction(a) {
    //   return function (b) {
    //     return function (c) {
    //       return a + b + c;
    //     };
    //   };
    // }
    // console.log(curryUnaryFunction(1)(2)(3));

    // High order function:Ex map, filter, and reduce,setTimeout(), setInterval(),fetch().then()
    // A higher-order function is a function that accepts another function as an argument or returns a function as a return value.
    // Takes another function as an argument (e.g., map, filter, forEach), OR
    // Returns another function.

//     Every callback is used inside a HOF.
// 👉 But not every HOF needs a callback, it could return a function instead.

//     function greet(name) {
//   return `Hello, ${name}!`;
// }

// // Higher-Order Function
// function greet(data){
//   return `Hello ${data}`
// }

// function hightFunc(calbck){    //✔ It takes another function (greet) as a parameter
//   const name = "Ritik"
//   return calbck(name)  //It uses func as a callback and executes it.
// }
// hightFunc(greet)

    // function highfunc(x){
    //   const y = 10;
    //   return function(y){
    //     return x+y
    //   }
    // }

    // const highfuncVar = highfunc(5)
    // console.log(highfuncVar(10));

    // const multiplier=(num)=>{
    //   return function(numInside){
    //     return num*numInside
    //   }
    // }

    // const highFunc = multiplier(2);
    // console.log(highFunc(5));

    //     function fun() {
    //     console.log("Hello, World!");
    // }
    // function fun2(action) {
    //     action();
    //     action();
    // }

    // console.log(fun2(fun));

    // const hightOrder=(fn)=>{
    //   return function(name){
    //     fn(name)
    //   }
    // }

    // const lowFunc=(dd)=>{
    //   console.log("Hello " + dd);
    // }
    // const hf = hightOrder(lowFunc)
    // console.log(hf);

    // console.log(hf("ritik"));

    // fun2(fun);

    // function greaterThan(n) {
    //   //greaterThan is a higher-order function because it returns another function.
    //   console.log("n", n);

    //   return (m) => {
    //     console.log("m", m,n);
    //     return m > n
    //   };
    // }

    // let greaterThan10 = greaterThan(10);   //it returns return statement and the this is called with 11 as value
    // console.log("greaterThan10", greaterThan10);
    // console.log(greaterThan10(11)); //greaterThan10 becomes a function generated by greaterThan(10), specifically a function that checks if its input is greater than 10

    //     function multiplier(factor) {
    //       console.log("factor",factor);
    //   return function (num) {
    //     console.log("num",num);
    //     return num * factor;
    //   };
    // }

    // const double = multiplier(2);
    // console.log("double",double);

    // console.log(double(5)); // Output: 10

    // const firstOrderFunc = () =>
    //   console.log("Hello, I am a First order function");
    // function higherOrder(ReturnFirstOrderFunc) {
    //   //A higher-order function is a function that takes one or more functions as arguments or returns a function as its resul
    //   ReturnFirstOrderFunc();
    // }
    // higherOrder(firstOrderFunc);

    // CALLBACK FUNCTION
    // Call back is a function passed as an arguement to another function which is then invoked inside that another function
    // to complete some kind of routine or action

    // function students(){
    //   console.log("Hi Students this side");
    // }

    // function teachers(calbck){
    //   console.log("Hi teachers this side");
    //   calbck()    //students is the callback function,
    // }

    // teachers(students);
    

    // function students(){
    //   console.log("Students Called")
    // }
    // function teacher(data){
    //   console.log("Teachers")
    //   data()
    // }
    // teacher(students)

    // function students(){
    //   console.log("Students here");
    // }

    // function teachers(data){
    //   console.log("Teachers here");
    //   data()
    // }

    // teachers(students)

    // const studentFunction=()=>{
    //   console.log("Students");
    // }

    // const teachersFunction=(callback)=>{
    //   console.log("Teachers");
    //   callback()
    // }

    // teachersFunction(studentFunction)

    // function students(calbck){
    //   console.log("students called");
    //   // calbck();
    //   setTimeout(()=>{
    //     calbck();             //if students delayed

    //   },2000)

    // }
    // function teachers(){
    //   console.log("teachers called");
    // }

    // students(teachers)

    // Pure function (No Side Effects)
    // pure function are function that accept an input and returns a
    // value without modifying any data outside its scope

    // let result = 10
    // const impureFunc=()=>{
    //   return (result + 2)
    // }

    // console.log(impureFunc());
    

    // const result = (x, y) => x + y
    // console.log(result(8,6));
    
    // const result = (a,b)=>{
    //   return a+b
    // }

    // console.log(result(3,8));

    // let resultVar = 0
    // console.log(resultVar);

    // function resultFunc(a,b){
    //  resultVar = a+b
    // }
    // console.log(resultFunc(2,67));
    // console.log("startIndex",resultVar);

    // console.log("result11",result);

    // function add(a, b) {
    //   return a + b;
    // }

    // console.log(add(1,2));

    // let result = 0; // External state
    // console.log("result", result);
    // function impureAdd(a, b) {
    //   result = a + b; // Modifies external state
    //   return result;
    // }

    // console.log(impureAdd(2, 3));
    // console.log("result", result);

    // let result = 0
    // console.log("result",result);

    // const imapureFunc = (x,y) =>{
    //   return x+y
    // }

    // console.log(imapureFunc(2,6));

    // ----------------------------------
    // -----------------------------------

//     const flatObj = {
//   name: "John",
//   address_city: "NY",
//   address_pin: 12345,
//   address_location_area: "Central"
// };


//     function unflatten(data) {
//   const result = {};

//   for (const key in data) {
//     const keys = key.split("_"); // split back the path
//     let current = result;

//     keys.forEach((part, index) => {
//       if (index === keys.length - 1) {
//         current[part] = data[key]; // assign value at last key
//       } else {
//         current[part] = current[part] || {}; // create nested object if not exists
//         current = current[part]; // go deeper
//       }
//     });
//   }

//   return result;
// }


// console.log(unflatten(flatObj));


    //     const nestedObj = {
    //   name: "John",
    //   address: {
    //     city: "New York",
    //     zip: {
    //       code: 10001,
    //       plus4: 1234
    //     }
    //   }
    // };

    // {
    //   "name": "John",
    //   "address.city": "New York",
    //   "address.zip.code": 10001,
    //   "address.zip.plus4": 1234
    // }

    // function flattenObject(obj, parentKey = '', result = {}) {
    //   for (let key in obj) {
    //     const newKey = parentKey ? `${parentKey}.${key}` : key;
    //     if (typeof obj[key] === 'object' && obj[key] !== null) {
    //       flattenObject(obj[key], newKey, result);
    //     } else {
    //       result[newKey] = obj[key];
    //     }
    //   }
    //   return result;
    // }

    // const flat = flattenObject(nestedObj);
    // console.log(flat);

//     To build the FULL key path during recursion.
// 👉 Without parentKey, you would lose context and only get:code 

// When recursion happens, every function call creates its own scope.
// If you don't pass result, each recursive call will create a new object, and you end up losing previously flattened keys.
    // console.log("nestedObj",flatObj(nestedObj));

  // const obj = {
  //   name: "Teja",
  //   greet() {
  //     console.log(this.name); // ?
  //   }
  // };
  // obj.greet();

  //   const obje = {
  //     name: "Teja",
  //     greet() {
  //       function inner() {
  //         console.log(this.name); // ?
  //       }
  //       inner();
  //     }
  //   };
  //   obj.greet();


// const payload = [23,5,23,67,30,20,10,-12,-13,65]

// function maximumtwoNumbers(data){
//   let maximumNoOne;
//   let maximumNoSecond;
//   let minimumNoOne;
//   let minimumNoSecond;
//   maximumNoOne = -Infinity;
//   maximumNoSecond = -Infinity;
//   minimumNoOne = Infinity;
//   minimumNoSecond = Infinity


//   let indexOfMaxOne = -1;
//   let indexOfMaxSecond = -1;
//   let indexOfMinOne = -1;
//   let indexOfMinSecond = -1;

//   data.forEach((num,index)=>{
//     console.log("num",num);
//     console.log("index",index);
    
//     if(num > maximumNoOne){
//       maximumNoSecond = maximumNoOne
//       indexOfMaxSecond = indexOfMaxOne
//     }
//     else if(num > maximumNoSecond){
//       maximumNoSecond = num;
//       maximumNoSecond = index
//     }
//   });

//   console.log("maximumNoOne",maximumNoOne);
//   console.log("maximumNoOne",maximumNoOne);
  
// }

// console.log("hello",maximumtwoNumbers(payload));


//  Find 2 no whose product is maximam and their indexes
















  </script>

  <body>
    <div>
      <!-- Event Bubbling -->
      <div onclick="alert('First Div')">
        //3
        <img onclick="alert('Second Div')" />
        //2 <button onclick="alert('Button alert')">Button</button> //1
        <!-- <p>Hello Ritik chauhan vats</p>
        <h3>Village _ Dahisra</h3>
        <h3>District - Sonipat</h3>
        <img
          src="./woman.png"
          alt="Girl in a jacket"
          width="500"
          height="600"
        /> -->
      </div>
    </div>
  </body>
</html>
<!-- 
type Geeks = {
  name: string;
  age: number;
};

type MoreGeeks = {
  email: string;
};

type CombinedGeeks = Geeks & MoreGeeks;

const gfg: CombinedGeeks = {
  name: "kgowda",
  age: 20,
  email: "kgowda@gmail.com"
};

console.log(gfg); -->

<!-- interface Geeks {
  name: string;
  age: number
}

interface Geeks {
  email: string;
}

// Using the merged interface
const gfg: Geeks = {
  name: &quot; kgowda&quot;,
  age: 20,
  email: &quot; kgowda@gmail.com&quot;
};


console.log(gfg); -->
<!-- Interface support the use of object -->

<!-- 
{
  "Resources": {
      "SimpleEC2Instance": {
          "Type": "AWS::EC2::Instance",
          "Properties": {
              "InstanceType": "t3.micro",
              "ImageId": "ami-0ff8a91507f77f867",
              "Tags": [
                  {
                      "Key": "Name",
                      "Value": "MySimpleInstance"
                  }
              ]
          }
      }
  }
} -->
