<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <script>
    // QUE:
    // const recurrArr = [{ Sunday: "true" }, { Monday: "true" }];
    //ANS
    // {
    //   "Sunday": true,
    //   "Monday": true
    // }

    // let recObj = {};
    // const dd = recurrArr.forEach((item, index) => {
    //   Object.keys(item).forEach((it) => {
    //     recObj[it] = item[it];
    //   });
    // });

    // console.log(recObj);

    // let recObj = {}
    // const obj = arr.forEach((item)=>{
    //   console.log("item",item);
    //   const ob = Object.keys(item);
    //   ob.forEach((it)=>{
    //     recObj[it]=item[it]
    //   })
    //   console.log("ob",ob);
    // })
    // console.log("obj",obj); //returning nothing
    // console.log(recObj);  //give desired output

    // FOR IN
    // const obj = { a: 1, b: 2, c: 3 };

    // for (let key in obj) {
    //   console.log(key); // Output: 'a', 'b', 'c'
    //   console.log(obj[key]); // Output: 1, 2, 3
    // }

    // FOR OF
    // const arr = [1, 2, 3];

    // for (let value of arr) {
    //   console.log(value); // Output: 1, 2, 3
    // }

    // const person = { firstName: "John", lastName: "Doe", age: 30 };
    // console.log(Object.entries(person));
    // console.log(Object.keys(person));
    // console.log(Object.values(person));
    // for (const [key,value] of Object.entries(person)) {
    //   console.log("key",key);
    //   console.log("value",value);
    // }

    // const existingPayload = {
    //   name: "ritik",
    //   age: "24",
    //   techStack: "ReactJS",
    //   city: {
    //     name: "new york",
    //     country: "USA",
    //   },
    // };

    // const newPayload = {
    //   name: "ritik",
    //   age: "24",
    //   techStack: "ReactJS",
    //   city: {
    //     name: "new york",
    //     country: "USA",
    //   },
    // };

    // function samePayload(obj1, obj2) {
    //   const keysArr = Object.keys(obj1);
    //   if (obj1.length !== obj2.length) {
    //     return false;
    //   }
    //   for (const element of keysArr) {
    //     if (obj1[element] !== obj2[element]) {
    //       return false;
    //     }
    //   }
    //   return true;
    // }

    // function samePayload(obj1, obj2) {
    //   const keysArr1 = Object.keys(obj1);
    //   const keysArr2 = Object.keys(obj2);

    //   if (keysArr1.length !== keysArr2.length) {
    //     return false;
    //   }

    //   for (const key of keysArr1) {
    //     // Check if the key exists in both objects
    //     if (!obj2.hasOwnProperty(key)) {
    //       return false;
    //     }

    //     const value1 = obj1[key];
    //     const value2 = obj2[key];

    //     console.log("value1",value1);

    //     // If the values are objects, recursively compare them
    //     if (typeof value1 === "object" && typeof value2 === "object") {
    //       if (!samePayload(value1, value2)) {   //if false not same it return false else if same it returns true (outermost return)
    //         return false;
    //       }
    //     } else {
    //       // Compare primitive values
    //       if (value1 !== value2) {
    //         return false;
    //       }
    //     }
    //   }

    //   return true;
    // }

    // console.log(samePayload(existingPayload, newPayload));

    // // Since both objects have identical properties and values and are serialized in the same order
    // const isPayloadEqual = JSON.stringify(existingPayload) === JSON.stringify(newPayload);

    // console.log(isPayloadEqual);

    // const areObjectsEqual = (obj1, obj2) => {
    //   const keys1 = Object.keys(obj1);
    //   const keys2 = Object.keys(obj2);

    //   if (keys1.length !== keys2.length) {
    //     return false;
    //   }

    //   for (let key of keys1) {     //simple for returning true or false
    //     if (obj1[key] !== obj2[key]) {
    //       return false;
    //     }
    //   }

    //   return true;
    // };

    // console.log(areObjectsEqual(existingPayload, newPayload)); // false

    // Note:

    // let obj1 = [
    //   {
    //     id: 1,
    //     name: "jack",
    //   },
    //   {
    //     id: 2,
    //     name: "leo",
    //   },
    //   {
    //     id: 3,
    //     name: "annie",
    //   },
    // ];

    // let obj2 = [
    //   {
    //     id: 4,
    //     name: "neil",
    //   },
    //   {
    //     id: 2,
    //     name: "nitin",
    //   },
    //   {
    //     id: 3,
    //     name: "mukesh",
    //   },
    // ];

    // const combinedArr = [...obj1, ...obj2];
    // console.log("combinedArr", combinedArr);
    // const onlyIds = combinedArr.map((item) => item.id);
    // console.log("onlyIds", onlyIds);
    // const duplicates = onlyIds.filter(
    //   (item, index) => onlyIds.indexOf(item) !== index
    // );
    // const replicates = combinedArr.filter((item)=>duplicates.includes(item.id));
    // console.log("replicates",replicates);
    // console.log("duplicates",duplicates);

    // const combineArr = [...obj1, ...obj2];
    // console.log("combineArr", combineArr);
    // const combineArrId = combineArr.map((item) => item.id);
    // console.log("combineArrId", combineArrId);
    // const duplicates = combineArrId.filter(
    //   (item, ind) => combineArrId.indexOf(item) !== ind
    // );
    // console.log("duplicates", duplicates);
    // const replicates = combineArr.filter((item, ind) =>
    //   duplicates.includes(item.id)
    // );
    // console.log("replicates", replicates);

    // check if they both contains same items or not
    // const a = [1, 2, 3];
    // const b = [1, 2, 3];

    // const check = a.every((item)=>b.includes(item));
    // console.log(check);

    // const sameArr = a.length === b.length && a.every((item)=>b.includes(item))
    // console.log("sameArr",sameArr);

    // NOTE : null equals to null or undefined
    // console.log(null===null);
    // console.log(null===undefined);
    // console.log(null==undefined);
    // console.log(typeof(null));
    // console.log(typeof(undefined));   //undefined
    // console.log(null == 0);
    // console.log(null == '');

    //Type Coercion
    // Numeric to String Coercion:
    // var num = 42;
    // var str = "The answer is " + num; // Coercion: number to string
    // console.log(str); // Output: "The answer is 42"
    // console.log(typeof str);

    // String to Numeric Coercion:
    // var str = "42";
    // var num = +str; // Coercion: string to number
    // console.log(num);
    // console.log(typeof num); // Output: 42

    //When an operation like subtraction (-), multiplication (*), division (/), or modulus (%) not (+) is performed, all the values that are not numbers are converted into the number data type
    // console.log(10 % "5")
    // console.log("number" + 15 + 3)  //+ has left-to-right associativity, so expression "number" + 15
    // console.log(15 + 3 + "number" )
    //Boolean to Number
    // console.log(false + 2); //converts false to 0 and then 0 + 2
    // console.log(Number(null));
    // console.log(Number(undefined));   //Its NAN
    // https://www.freecodecamp.org/news/js-type-coercion-explained-27ba3d9a2839

    // Comparison Coercion:(== , !=) convers string to number
    // comparison operators (>, <, <=,>=)
    // bitwise operators ( | & ^ ~)
    // console.log('true' == true);  //== operator triggers numeric conversion,;'true' is converted to string i.e, to NaN and true is 1
    // console.log(42 == "42");  //In this case, the loose equality operator == coerces the string "42" into a number before comparing it with the number 42.

    // console.log([]=="");
    // console.log([]==![]);     //!coverts it to boolean(false) JavaScript attempts to convert the operands to the same type.
    // "" == 0    //type coercion if the operands are of different types
    //0 == 0    //again coercion
    // console.log(true + "10"); // Boolean TO STRING The Boolean value true is converted to string 'true'
    // console.log(true + +"10");
    // console.log(true + 10); //Boolean To NUMBER
    // console.log(12 / "6"); //Arithmetic division operator / triggers numeric (12/6)
    // console.log([1] > null);      //Comparison operator triggers numeric conversion
    // console.log(!!"false" == !!"true"); //sinnce they are non-empty strings so both are true
    // console.log(['x'] == 'x');    //Arrayâ€™s toString() converts ['x'] to just 'x' string.
    // console.log([] + null + 1);   //empty array in ""
    // console.log(3 > 2 >= 1);    //false
    // console.log(1 > 2 > 3); //false non-numeric value to a number
    // console.log(2 > 1 > 0); //false non-numeric value to a number
    // console.log("%cThis is a red text", "color:red");
    // const person = {
    //   name: "batMan",
    //   age: 21,
    // };
    // console.log(Object.keys(person));   //gives array of keys
    // console.log(Object.values(person));     //gives array of values
    // for (const item in person) {
    //   //it will give keys of object
    //   console.log(item);
    // }

    // const obj = { 1: "a", name: "b", 3: "c" }; //we can define an obj key as an number but not var,let name
    // console.log(obj.hasOwnProperty("1")); //you can use that number as string or number it works for
    // console.log(obj.hasOwnProperty("name")); //both
    // console.log(Object.keys(obj).length);

    // const arr = [10, 10, 10, 10, 10, 10].map(parseInt); //parseInt("10", 1) The radix is 1, which is not a valid radix. Therefore, NaN is returned.
    // console.log(arr); //parseInt("10", 2) is called. The radix is 2, so "10" is interpreted as a binary number, and the result is 2

    // It's due to different scopes of both the variables
    // var num = 8; //memory allocated to num variable with a variable
    // function display() {
    //   //memory allocated to display()
    //   num = 10;
    //   console.log(num);
    // }
    // display(); //function is called
    // console.log(num);

    // var num = 8;
    // function display() {
    //   var num = 10;
    //   console.log(num);
    // }
    // display();
    // console.log(num);

    // console.log("2" * "8")    //multiplication operator (*) implicitly converts the string values to numbers before performing the multiplication.
    // console.log(2 + "4" * "2")  	  //BODMAS ; When + is used with -,* etc
    // console.log(1 + "1");
    // console.log("1" + "1" - 1);
    // console.log("2" > "12"); //in lexicographical order ,The comparison starts with the first characters of the two strings: "2" and "1".
    // console.log(2 > 12);
    // console.log("2" > 12);
    // console.log("2">"32");
    // console.log(String([1,2,3]));
    // console.log(1+ [1,2,3]);
    // console.log([1,2,3] + [4,5,6]);     //+ operator with arrays, it performs array-to-string
    // console.log(!true-true);
    // console.log(true + "10");    //Boolean to string
    // console.log(true + 10);      //Boolean to number
    // console.log(true + +"10");
    // const arrs = [1, 2, 3, 4, 5, 7, 2, 1, 5];
    // const repeats = arrs.filter((it, index) => arrs.indexOf(it) !== index);
    // const uniques = arrs.filter((it, index) => arrs.indexOf(it) === index);
    // const duplicates = arrs.filter((item,index)=>repeats.includes(item));
    // console.log(duplicates);

    // const ff = [...new Set(arrs)];
    // const ff = arrs.filter((it, index) => arrs.indexOf(it) !== index);
    // const repeatedNumbers = arrs.filter((it) => ff.includes(it));
    // console.log(repeatedNumbers);

    // const ff = arrs.filter(
    //   (it, index) => arrs.findIndex((item) => item === it) === index
    // );
    // const ff = arrs
    //   .map((it, index) => {
    //     if (arrs.indexOf(it) !== index) {
    //       return it;
    //     }
    //   })
    //   .filter((item) => item !== undefined);

    // console.log(ff);

    // sort and splice affects main array
    // null : It is often used as a placeholder or to indicate that a variable or property has no assigned value.
    // let variable=null;
    // console.log(variable);
    // undefined : is a primitive value that is automatically assigned to variables that have been declared but not initialized any value.
    // let variable;
    // console.log(variable);

    // 1. Operations in javascript are performed from left to right
    // 2. If we add + sign in front of string(+"8") it become number
    // 3. delete return true or false;it only deletes(key value) property not obj.
    // 4. if we delete Array index then it deletes it and write empty there
    // 5. Set removes duplicay from array [...new Set(array)]
    // 6. a=[] ...a makes array element out removing ,
    // a=[1,2,3]  {...a} makes array of object with index as keys
    // console.log(...[1,2]);
    // console.log(1+[1,2]);
    // console.log("1"+[1,2]);
    // 11. spread before array func(...[1,2]) converts it into string
    // console.log([..."anil"]);                 //it will break string and make it an array of string
    // console.log(..."anil");           //it make character out of string seperately
    // console.log(...['anil','hi']);
    // 7. ex=true || false && false;
    // console.log(true || true && console.log("1"));
    // console.log(true || true && 10);
    // 8. bCondition1 && bCondition2 is same !(!bCondition1 || !bCondition2)
    // 9. FALSE  =  null ; NaN ; 0 ; empty string ("" or '' or ``) ; undefined.
    // console.log(Boolean({}))
    // 10. nullish operator (??) returns its right-hand side operand when its left-hand
    //  side operand is null or undefined, and otherwise returns its left-hand side operand.
    // 12.During event propagation, there are 3 phases: capturing, target, and bubbling.The deepest
    //  nested element that caused the event is the target of the event.
    //  You can stop bubbling by event.stopPropagation.
    // NOTE:If we click p, we see two logs: p and div.
    // NOTE:typeof null returns "object"
    // 13. here are 8 falsy values: undefined, null, NaN, false, '' (empty string), 0, -0, 0n (BigInt(0))
    // 14. Primitive types are boolean, null, undefined, bigint, number, string, and symbol.
    // 15. 15/2 = Q:7
    // 16. 15%2 = R:1
    // 17. += concatinate and assign
    // >=
    // console.log(3+4+'6');
    // console.log(typeof 3+4+'6');        //o/p are performed from left to right,type of 3 is number+46
    // console.log(typeof (3+4+'6'));
    // let data = 3 + 4 + "5";
    // console.log(data);
    // console.log(typeof data);

    // let abs = { name: "ritik", age: 12, skill: "rosk" };
    // console.log([abs]);
    // console.log(...[abs]);
    // console.log(...abs);      //Spread syntax requires ...iterable
    // console.log("hi" || (false && false));   //  return true

    // let abs = [{ name: "ritik" }, { age: 12 }, { skill: "rosk" }];
    // console.log(...[abs]);
    // console.log([...abs]);
    // console.log(...abs);
    // console.log({ abs });
    // console.log([ abs ]);

    // let arr=["js","react","vscode"]
    // let arr = [1, 7, 2, 6, 3, 4];
    // const arrs=arr.push("c#","234")      //pushed item in last of array
    // console.log(arrs);    //gives count on no of elements
    // arr.unshift("c++","123")      //pushed item in first of array
    // arr.pop()               //delete item in last of array
    // arr.shift()              //delete item in first of array
    // arr.fill(1)               //fill every element with one
    // const arrs=arr.reverse()               //reverse array
    // console.log(arrs);    //gives reversed array
    // let newArr = arr.map((item) => item * 2); //returns new array with updated values and doesn't affect previous array
    // let newArr=arr.includes(1);        //returns true or false if condition matches
    // let newArr = arr.filter((item,index,array) => {
    //   console.log(item);
    //   console.log(index);
    //   console.log(array);
    //   return item !== 2
    // }); //returns new array with filtered values, it removes the element whose condition matches
    // let newArr = arr.filter((item) => item === 2); //if condition is true it takes it out that item
    // let newArr=arr.find((item)=>item>2);     //returns only(7) first value after condition matches
    // let newArr = arr.some((item) => item > 3); //returns true if either one codition satisfies
    // let newArr = arr.every((item) => item > 3); //returns true when all the codition satisfies
    // let newArr = arr.findIndex((item) => item === 3); //returns index if condition matches if not matches returns (-1)
    // const fruits = ["apple", "banana", "orange", "banana", "grape"];
    // const bananaIndex = fruits.indexOf("banana");
    // console.log(bananaIndex);
    // let newArr = arr.reduce((prev, curr) => {   //prev is what what you give in dependency
    //   console.log("prev",prev);
    //   console.log("curr",curr);
    //   return prev + curr
    // }, 0); //gives sum of all numbers
    //initially prev is 0 and curr[0] is 1 then prev is added value and prev is 1,initialValue is 0

    // function ssuumm(data) {
    //   let sum = 0;
    //   data.forEach((element) => {
    //     sum += element;
    //   });
    //   return sum;
    // }

    // console.log(ssuumm(arr));

    // function sum(data){
    //   let s = 0;
    //   data.forEach(element => {
    //     s += element
    //   });
    //   console.log("s",s);
    //   return s
    // }

    // console.log(sum(arr));

    // let newArr = arr.join("+");       //convert array into string with + seperated
    // let newArr = arr.toString();          //convert array into string with , seperated
    // console.log("hello", ...arr.join("/"));      //iterates without , seperation
    // const newArr = arr.splice(3,0,"i","p");          //add 2(inclusive) no on 3nd index and dont' remove any ahead elemnet
    // let newArr=arr.slice(0,3);  //Slice from the 1st element to the 3rd element (non-inclusive means delete 3rd index also):         //deletes array element of given index  (Extract elements from index 0 (inclusive) to index 3 (exclusive))
    // let newArr=arr.slice(1,3);    //Slice from the 2nd element to the 4th element (non-inclusive 1 and delete ahead indexes inclusive 3):
    // let newArr=arr.sort();          //sort no alphabetically;; affect main arr

    // console.log("newArr", newArr);
    // console.log("arr", arr);

    //extract a section of an array and return a new array.(SLICE) It doesn't modify the orignal array
    // NOTE:If the start index is greater than or equal to the end index, it returns an empty array.
    // var originalArray = [1, 2, 3, 4, 5];
    // var portion = originalArray.slice();
    // var portion = originalArray.slice(6, 3);
    // var portion = originalArray.slice(1, 4); //This extracts elements from index 1 to (4-1) = 3. The resulting portion array will be [2, 3, 4].
    // var portion = originalArray.slice(2, 4);      //4-1 means 3rd index
    // var portion = originalArray.slice(0, 4);      //array will include elements from index 0 to 4 - 1 = 3, resulting in [1, 2, 3, 4].
    // var portion = originalArray.slice(2);       //This extracts elements starting from index 2 to the end of the array. The resulting copyToEnd array will be [3, 4, 5].
    // var portion = originalArray.slice(-3);        // (-3-1 = 2index) This extracts the last three elements of the array, regardless of the array's length.
    // var portion = originalArray.slice(-3,4);
    // console.log("originalArray", originalArray);
    // console.log("portion", portion);

    //(SPLICE)It modifies the array it's called on and **returns an array containing the deleted elements;return empty []array with added values
    // var array = [1, 2, 3, 4, 5, 6, 2];
    // var removed = array.splice(2, 2); //removes two elements starting from index 2(start from index inclusive means delete it also).
    // var addArr = array.splice(2, 0, 6, 7);    //inserts 6 and 7 at index 2(start from index inclusive means add at it place also) without removing any elements.
    // var removed = array.splice(0, 2);     //(2-1=1index)start from index 0 and remove elements upto 2 index(non inclusive means don't delete second index element)
    // var removed = array.splice(-2);     //When you use a negative index with splice, it starts counting from the end of the array. In this case, -1 refers to the last element, and -2 refers to the second-to-last element
    // var removed = array.splice(-3, 2);
    // (-2-1=1index)starting from last index to -2 index means delete elements from last index to -2 index(not - inclusive means don't delete -2 index element)
    // var removed = array.splice(2, 1, 'a');       //add a and b
    // var removed = array.splice(2, 0, 'a');
    // var adding = array.splice(array.length, 0, 6, 7); //add 6 and 7 at the last of array
    // console.log("array", array); //it is modified array,array is now [1, 2, 5]
    // console.log("addArr", addArr); //it gives deleted values,removed is [3, 4]
    // console.log("removed", removed); //adding array element give empty array
    // console.log("adding", adding);
    // console.log("array", array);

    // let arr = [1, 2, 3, 4]; //returns (undefined )it doesn't give new array instead it modifies the orignal array
    // const newArr = arr.forEach((element, index, array) => {
    //   //not need to return anything as we are manipulating array elements
    //   console.log("element", element); //array elements
    //   console.log("index", index);
    //   console.log("array", array); //full array arr changes again and again

    //   array[index] = element * 2;
    //   return "true"
    // });
    // console.log(arr);
    // console.log(newArr);

    // NOte :: Saving in other variable gives you deleted things

    // let a = ["1", "2", "3", "4"];
    // let b = ["6", "7", "3", "2"];

    // const c = [...a, ...b];
    // const arr = c.filter((it, index) => c.indexOf(it) === index);
    // console.log("arr", arr);

    // console.log([...new Set(c)]);
    // const ff = a.concat(b.filter((item, index) => !a.includes(item)));
    // console.log("ff", ff);

    // const arr = c.filter((item, ind) => c.indexOf(item) === ind);
    // console.log(arr);
    // const filtt = a.concat(b.filter((item) => !a.includes(item)));
    // console.log("filtt", filtt);

    // const arrs = [1, 2, 3, 4, 5, 7, 2, 1, 5];
    // const ff = arrs.filter(
    //   // (item, index) => arrs.findIndex((it) => it === item) === index
    //   (item, index) => arrs.indexOf(item) === index
    // );
    // console.log("ff", ff);

    // const ff = arrs.filter((item, index) => arrs.indexOf(item)===index);
    // const ff = arrs.filter(
    //   (item, index) => arrs.findIndex((it) => it === item) === index
    // );

    // console.log("ff", ff);

    //   const arr = b.filter((it)=>!a.includes(it));
    //   console.log("arr",a.concat(arr));

    //  const total = [...a, ...b];
    // console.log("total", total);
    // console.log(new Set(total)); //it gives an obj
    //  console.log(new Set(total)); //spreading obj remove , and give element
    //  console.log([...new Set(total)]); //is to make array

    // let mergedUnique = a.concat(b.filter(item => !a.includes(item)));
    // console.log("Merged Array with Unique Values:", mergedUnique);
    // let mergedUnique = [...new Set([...a, ...b])];
    // console.log("Merged Array with Unique Values:", mergedUnique);

    //  result = "foo" && 4; // result is assigned 4, if both true it returns right side
    //  result = "" && "foo"; // result is assigned "" (empty string)
    //  result = "foo" && "";
    //  a8 = "Cat" && "Dog"; // t && t returns "Dog";both true returns right side
    //  a8 = "" && false; // both false returns "" , returns left side
    //  a8 = false && "";
    // let result = "foo"  || 4;          // result is assigned 4, if both true it returns right side
    //  result = "" || "foo";          // result is assigned foo
    //  result = "foo" && "";      // result is assigned "" (empty string)
    //  a8 = "Cat" || "Dog";           // t && t returns "Dog";both true returns right side
    //  a8 = false || null;        	    //return right side if both false
    //  a8= false || '' || null;
    //  console.log("a8",a8);
    //  console.log("result",result);

    // const foo = (null) ?? "default string"; //if 1st condition is null or undefined it returns right side
    // console.log(foo); //else it returns left condition

    // const baz = 0 ?? 42;      //as 0 is not null or undefined
    // console.log(baz);

    // function getAge(...args) {
    //   console.log(args); //spread operator makes it an array
    //   console.log(...args);
    //   console.log(typeof args); //type of arguement is object
    // }
    // getAge(21);

    // for (var i = 0; i < 3; i++) {        //it only updates one key, captures the variable i by reference
    //   console.log(i);
    //   setTimeout(() => console.log(i), 2000);
    // }

    // now it's in global scope and behaves like var
    // for (let i = 0; i < 3; i++) {     //it creates 3 lets
    //   console.log(i);
    //   setTimeout(() => console.log(i), 1);
    // }

    // let radius = 11;
    // const shape = {
    //   radius: 10,
    //   diameter() {
    //     return this.radius * 2; //with regular function this keyword refers to its current surrounding scope,
    //   }, //example shape object
    //   perimeter: () => 2 * radius, //fat arrow fun doesn't refer to the shape object,it's
    // }; //surrounding scope is window for example
    // they inherit the this value from the enclosing function or context but it's a object.
    // , it doesn't refer to the shape object's radius, but rather it refers to the radius variable in the outer scope

    // console.log(shape.diameter());
    // console.log(shape.perimeter());

    //Getting key from OBJECT by DOT method and by ARRAY Method
    // const bird = {
    //   size: "small",
    // };

    // const propertyName = "size";
    // console.log(bird[propertyName]); // Accessing the property using a variable
    // console.log(bird.propertyName); //undefined

    // const book = {
    //   "title with spaces": "JavaScript Guide",
    //   "year published": 2022,
    // };

    // console.log(book["title with spaces"]); // Output: JavaScript Guide
    // console.log(book.title with spaces);

    // const bird = {
    //   size: "small",
    // };
    // const mouse = {
    //   name: "Mickey",
    //   small: true,
    // };

    // console.log(mouse[bird.size]);
    // console.log(mouse[bird["size"]]);

    // let c = { greeting: "Hey!" };
    // let d;
    // d = c;
    // console.log(d === c);
    // c.greeting = "Hello"; //you change one object, you change all of them
    // console.log(d.greeting); //as c and d have same reference

    // console.log(new Number(3));         //it's an object whose value is 3

    // function getPersonInfo(one, two, three) {
    //   console.log(one); //tagged template literals, the value of the first argument is                                    // always an array of the string of empty values
    //   console.log(two); //The remaining arguments get the values of the passed expressions
    //   console.log(three);
    // }
    // const person = "Lydia";
    // const age = 21;
    // getPersonInfo`2344  cc ${person} is cvdfg df ${age} years old`;

    // function checkAge(data) {
    //   if (data === { age: 18 }) {
    //     //The two objects that we are comparing don't have tha
    //     console.log("You are an adult!"); //t: the object we passed as a parameter refers to a different location in memory
    //   } else if (data == { age: 18 }) {
    //     console.log("You are still an adult.");
    //   } else {
    //     console.log(`Hmm.. You don't have an age I guess`);
    //   }
    // }
    // checkAge({ age: 18 });

    // function getAge(...args) {
    //   console.log(args);
    //   console.log(...args);
    //   console.log(typeof args);
    //   console.log(typeof []);
    // }
    // getAge(21);

    // function getAge(...args) {
    //   console.log(args);
    //   console.log(...args);
    //   console.log(typeof args);
    //   console.log(typeof []);
    // }
    // getAge([21,22]);

    // let a=[];
    // let b=[];
    // console.log(a==b);     //when we compare 2 array it actually compare its memory location
    // console.log(a===b);

    // let a=[];
    // let b=a;
    // console.log(a==b);
    // console.log(a===b);

    // let a=[20];
    // let b=[20];
    // console.log(a[0]==b[0]);       //we specified element so value will be compared
    // console.log(a[0]===b[0]);

    // let z = [1, "hgcv", 2, 3, 4];
    // let a = { name: "ritik" };
    // console.log(z);
    // console.log(...z); //it breaks array,object into its elements

    // let a="hi"
    // console.log(typeof a/5);       //Nan

    // console.log(typeof NaN);        //NaN is obtain when we divide non-numeric value like string,obj etc

    // let data=10 - -10;              //mathematics rule
    // console.log('data',data);

    // const set = [...new Set([1, 2, 3, 1, 2, 3, 4, 5, "hi", "bingo", "dd", "hi"])]; //set removes duplicacy of elements
    // console.log(set);

    // let a=["1","2","3","4"]
    // let b=["6","7","3","2"]
    // const arr=[...a,...b]
    // console.log([...new Set(arr)]);
    // const ab=a.filter((it)=>b.includes(it))
    // console.log(ab);

    // let data = { name: "anil", age: 98 };
    // console.log(data);
    // console.log(delete data.name); //it returns trur or false ; wew can delete key-value by giving key name
    // console.log(data); //after deleting data is an empty {}
    // console.log(delete data); //we can delete property of data but not data object**

    // let data = ["anil", "peter", "bruce", "lee"];
    // delete data[1];                 //it deletes key value (index with value) peter and write empty there
    // console.log(data);

    // const data = ["Hi", "hello", "king"];
    // const [y, z] = data; //ARRAY DESTRUCTURING gives first value of array element
    // console.log(y, z);
    // const [, , a] = data; //gives first arrray index value of array element [1]
    // console.log("a : ", a); //without z wanted to get 2nd value

    // let a = { name: "ritik", age: 12, saill: "rosk" };
    // let b = { school: "gbsss", saill: "rk" };     //merge 2 objects
    // console.log(...[a]);
    // let c = { ...a, ...b };
    // console.log(c);                             //if we have skill common in both objects we get saill key
    // c = { a, ...b };                             // of upper object and value of lower object
    // console.log(c);

    // a = 10;
    // console.log(typeof a); //Variable hoisting
    // console.log(a);
    // let a;

    // let a = [1, 2, 3, 4, 5];
    // let b = [4, 5, 6];
    // console.log(...a);                         //it doen't replace
    // let c = [...a, ...b]; //it takes both 4 in the array
    // console.log(c);
    // console.log([...new Set(c)]);

    // const a = [1, 2, 3, 4, 5, 4, 5, 6];
    // const resp = a.filter((value, index, self) => {
    //   // console.log("value", value);
    //   // console.log("index", index);
    //   // console.log("self", self); //it is used to take orignal array
    //   // console.log(self.findIndex((it)=>console.log(it)));
    //   // console.log(self.findIndex((it)=>it===value));
    //   // console.log("self.indexOf(value)", self.indexOf(value));
    //   return self.findIndex((it)=>it===value) === index;
    //   // return self.indexOf(value) === index; //index of gives index of value
    // });
    // console.log("resp", resp);

    // let a = [1, 2, 3];
    // let b = [4, 5, 6];
    // let c = [...a, ...b]; //it merges 2 array
    // let d = { ...a }; //it makes array an object with index as keys
    // console.log(c);
    // console.log(...b); //make array elements out from array
    // console.log(d);

    // const result=false || {} || null;               //prints obj bcoz it's +ve and true value
    // const result1=false || '' || null;              //it picks last entry bcoz all 3 are false
    // console.log(result);
    // console.log(result1);

    // let name = "sidhu"; //let has block level scope & it can't pursue variable hoisting
    // function getName() {
    //   let name = "jk";
    //   console.log(name); //local variable & global variable
    //   // let name="pal";
    // }
    // getName();

    // console.log(`${(x=>x)('I love')} to program`);

    // function sumValues(x, y, z) {
    //   return x + y + z;
    // }
    // console.log(sumValues(1, 5, 3)); //spread before array func(...[1,2]) converts it into string
    // console.log(...[1, 5, 3]);
    // console.log(sumValues(...[1, 5, 3]));

    // const name = "code";
    // console.log(typeof name); //name is not empty string so it's true, ! makes it false
    // console.log(!typeof name); //& when false it compared with (not empty string) it
    // console.log(!typeof name === "object"); //returns false
    // console.log(!typeof name === "string");
    // console.log(typeof false);

    // let person = { name: "anil" };
    // console.log(person);
    // person.age = 30;
    // console.log(person);
    // // //add new key in object
    // Object.seal(person); //after applying seal we cann't add new key but can modify person
    // // // console.log(person);
    // person.name = "king"; //cann't add new key but can modify the name key
    // person.class = "hello";
    // console.log(person);

    // const data = [2, 4, 5, 6, 0];
    // let string = "Hi this is Ritik";
    // let sp = string.split(" ");
    // console.log(sp);
    // let dele = data?.splice(0, 1);     //modifies orignal array
    // console.log(dele);
    // console.log(data);
    // let del = data?.slice(0, 1);        //gives new array
    // console.log(del);
    // console.log(data);
    // let shift = data?.shift();
    // console.log(data?.shift());
    // console.log("Removed array element", shift);
    // console.log("All rest array elements", data);

    // const data="true";
    // console.log(Boolean(data));                     //convert string to boolean
    // console.log(typeof !!data);

    // let a = 2;
    // setTimeout(() => {
    //   console.log(a);
    // }, 0); //it runs st before that the
    // a = 100; //value of a already become 100

    // let a = 1;
    // let b = 1;
    // let c = 2;
    // console.log(a === --c); //-- decrement happens so c=1 and returns true
    // console.log((a === b) === --c); //a===b is true and now boolean is compared to number

    // console.log([[[[]]]]);                          //3 array element has length 1 and 4th have length 0

    // (Important)
    // function fruit() {
    //   //  name="apple";               //give value here
    //   console.log(name);
    //   var name = "apple"; //var gets hoisted with the default value of undefined
    //   let price = 20;
    // }
    // fruit();

    // for (let i = 0; i < 3; i++) {
    //   setTimeout(() => {
    //     //setTimeout etc mover in a stack of our code & runs at the end
    //     console.log(i); //var is decalared globally
    //   }, 1000);
    // }

    // let data = "size";
    // const bird = {
    //   size: "small",
    // };
    // console.log([data]); //so same case like log 2
    // console.log(bird[data]); //when we have to use var with object then obj[]
    // console.log(bird["size"]);
    // console.log(bird.size);
    // console.log(bird.data);

    // let c = { name: "anil" };
    // let d;
    // d = c;
    // c.name = "kumar"; //we get latest value as memory loc of c and d are same
    // console.log(d.name);

    // let a = 3;
    // let b = new Number(3);
    // console.log(new Number(3)); //it's an object but it's value is 3
    // console.log(a == b);
    // console.log(a === b);

    // function sum(x, y) {
    //   return x + y;
    // }
    // console.log(sum(1, "2"));
    // console.log(sum(1, 2));

    // let number = 0;
    // console.log(number++); //post increment it prints 0 but the value become 1
    // console.log(++number); //pre increment value become 2 then printed
    // console.log(number);

    // function getAge(...args) {
    //   //spread operator makes it an array
    //   console.log(...args);
    //   console.log(typeof args); //type of arguement is undefined
    // }
    // getAge(21);

    // function getAge(...args){
    //     'use strict';                            //but use-strict says follow rules strictly,no hoisting etc
    //     age=21;                                 //whenever we don't define let,var etc it auto takes it var
    //     console.log(age);
    // }
    // getAge(21);

    // const sum = eval(10 * 10 + 5 - 2); //eval does the mathematical calculations
    // console.log(sum);

    // const obj = { cat: "one", bat: "two", cat: "repeat" }; //prints key of first a and value of second a
    // console.log(obj);

    // for (let i = 0; i < 5; i++) {
    //   if (i === 3) {
    //     continue; //continue will not print rest code when the condition matches
    //   }
    //   console.log(i);
    // }

    // const person = { name: "anil" };
    // function sayHi(age) {
    //   console.log(age);
    //   return `${this.name} is ${age}`;
    // }
    // console.log(sayHi.call(person, 21)); //it's called on it's own no callback is required
    // console.log(sayHi.bind(person, 21)); //returns function as it is with added properties
    // console.log(sayHi.bind(person, 21)()); //callback is required,bind is called manually

    // ***
    // function sayHello(){
    //     return(()=>0);                      //it returns a function
    //     // return(()=>0)();                    //it returns a zero as fat arrow fun is called
    // }
    // console.log(sayHello()());
    // console.log(typeof sayHello());
    // console.log(typeof sayHello()());           //it also returna a number

    // console.log(typeof typeof 1);        //typeof 1 is number & number is a string which is a string

    // const numbers = [1, 2, 3];
    // numbers[6] = 11; //index 3,4,5 become empty
    // console.log(numbers);

    // const numbers = [1, 2, 3];
    // numbers[6] = numbers; //everytime at 6th index it pushes an array
    // console.log(numbers);

    // console.log(!!null);
    // console.log(!!"");
    // console.log(!!1);

    // console.log([..."anil"]);                 //it will break string and make it an array of string
    // console.log(..."anil");           //it make character out of string seperately
    // console.log(...['anil','hi']);    //it make word come out

    // // **Imp
    // let person={name:'anil'}        //mem loc. of obj and array is diff. so
    // const member=[person];          //when we null object it doesn't null the array
    // person=null;
    // console.log(member);
    // console.log(person);            //makes person null object

    // let data = 3 + 4 + "5";
    // console.log(data);
    // console.log(typeof data);

    // console.log(typeof typeof false);
    // console.log(typeof 3+4+'6');        //o/p are performed from left to right,type of 3 is number+46
    // console.log(typeof (3+4+'6'));
    // console.log(typeof (3+4+ +'6'));        //if we add + sign in front of string(+"8") it become number

    // const a = [];
    // let b = a;
    // console.log(a === b);
    // console.log([] == []); //memory loc of both the array's is different

    // let data=[1,2,3].map((item)=>{
    //   console.log(typeof item==='number');
    //     // if(typeof item==='number') return;    //as it's not returning anything so it returns undefined
    //     return item*2;
    // });
    // console.log(data);

    // **Imp
    // function getInfo(member) {
    //   console.log(member); //memeber is obj inside member name key is modified
    //   member.name = "singh";
    // }
    // const person = { name: "Ritik" }; //when we pass object in a function call by refernce works
    // getInfo(person); //and when we changes it in function it auto changes in person obj
    // console.log(person); //due to same reference

    // (() => {
    //   let x = (y = 10); //undefined because x have block level scope
    //   console.log(x,y);
    // })(); //fat arrow function is called
    // console.log(typeof x);

    // (() => {        //Immediately Invoked Function Expression (IIFE)
    //   let x = (y = 10); //bcoz it's like let x=10,var y=10 & var has global scope
    //   console.log(x,y);
    // })(); //so y is accessible outside
    // console.log(typeof y);

    // (() => {
    //   var x = (y = 10); // var x makes it a block level scope while y is global scope
    // })();
    // console.log(typeof x);
    // console.log("x : ", x);
    // console.log(typeof y);

    // let x = 100;
    // (() => {
    //   var x = 20; //now it act's as block bcoz x is already declared outside
    // })(); //so y is accessible outside
    // console.log(x);

    // console.log(!true-true);        //true=1 !true=0 so 0-1=-1

    //1+10(number bcoz string is converted to number by + before string)

    // STRING QUESTIONS

    // let str = "Hello, How are you?";

    //1.Convert string in only one array

    // console.log([str]);
    // console.log(str.split())
    // console.log(str.split(""));           //give array of words
    // console.log(str.split(" "));         //give array of characters

    //2.Convert string to array with each character
    // console.log(...str);
    // console.log([...str]);

    //3.Convert string to array on the basis of a chacter
    // console.log(str.split('a'));

    //4.replace any chacter
    // console.log(str.replace('H','W'));      //works on single character
    // console.log(str.replace(/H/g,'W'));     //works for all characters

    // 5.get string from subString
    // console.log(str.substring(0,5));

    //6.Remove first character from string
    // console.log(str.substring(0,str.length));

    // 7.reverse a string
    // console.log(str.split("").reverse().join(""));    //array can be reversed not string

    // 8.Remove empty spaces
    // console.log(str.trim());

    // 9.Concat two string
    // let a="hello";
    // let b="Candidate"
    // let c= a+' ' +b
    // console.log(String(c));

    // const b = [1, 2, 3];
    // console.log("b", b.push(4));
    // console.log("b", b);

    // ARRAY QUESTIONS

    // let data = [2, 4, 6, 3, 7, 3, 6, 4, 9, 5];

    // console.log(data.reduce((x,y)=>x+y));

    // function summ(dd){
    //   let sm = 0;
    //   dd.forEach(element => {
    //     sm += element
    //   });
    //   return sm
    // }

    // console.log(summ(data));

    // function sum(dd) {
    //   let sum = 0;
    //   for (let index = 0; index < dd.length; index++) {
    //     sum += dd[index];
    //   }
    //   return sum;
    // }

    // console.log(sum(data));

    // var sum = 0;
    // const aa = data.forEach((e, i) => {
    //   sum += e;
    // });
    // console.log(sum);

    // 1.Find sum of all array elements
    // let sum = data.reduce((x, y) => x + y, 0);
    // console.log(sum);

    // let sum = 0;
    // for (let index = 0; index < data.length; index++) {
    //   sum += data[index];
    // }
    // console.log("sum", sum);

    // let sum = 0;
    // for (let i = 0; i < data.length; i++) {
    //   sum += data[i];
    // }
    // console.log(sum);

    // const a = [1,4,5]
    // var sum = 0
    // for (let index = 0; index < a.length; index++) {
    //   sum += a[index];
    // }
    // console.log(sum);

    // let x =  10;
    // x = (x++, x); //first perform action second prints the outcome
    // x = ((x += 10), x);
    // x = ((x += 10), 6);
    // x = ((x += 10), 6); //, 6 is a comma operator that evaluates expressions from left to right and returns the value of the last expression, which is 6.
    // console.log(x);

    // CLOSURES
    //a closure gives you access to an outer function's scope from an inner function.

    // function outer(){
    //   let x = 10;
    //   return function inner(){
    //     return x
    //   }
    // }

    // console.log(outer()());

    // function outer(){
    //   const num = 10;
    //   console.log("outer function");
    //   return function inner(){
    //     console.log("num",num);
    //     console.log("inner Function");
    //   }
    // }

    // function outFunc() {
    //   const ab = 10;
    //   return function innerfunc() {
    //     console.log(ab);
    //   };
    // }

    // const closure = outFunc();
    // console.log(closure());

    // function outFunc(){
    //   const a = 8
    //   console.log("OUter Called",a);
    //   return function innerFunc(){
    //     let b = 3;
    //     console.log("inner called ",a + b);
    //     return a + b
    //   }
    // }

    // console.log(outFunc()());

    // console.log(outer()());

    // function out(){
    //   console.log("out");
    //   const a = 10

    //  return function iner(){
    //     console.log("iner",a);
    //   }
    // }

    // console.log(out()());
    // function outerFunction(outerVariable) {
    //   console.log("outerVariable", outerVariable);
    //   // This is the inner function, which is a closure (LEXICAL SCOPING)
    //   function innerFunction(innerVariable) {
    //     console.log("innerVariable", innerVariable);
    //     console.log(outerVariable + innerVariable);
    //   }

    //   // Return the inner function
    //   return innerFunction || "No Paraeter passes";
    // }
    // outerFunction(12)(13);

    // Create a closure by calling outerFunction
    // const closure = outerFunction(10);
    // console.log("closure",closure);     //When we call outerFunction(10), it returns the innerFunction, creating a closure.
    // //The innerFunction now has access to the outerVariable, even though outerFunction has finished executing.
    // // Use the closure
    // closure(5); // Outputs: 15

    // function x(){
    //   const a=7;
    //   function y(){
    //     console.log(a);     //lexical scoping
    //   }
    //   y();
    // }
    // x();

    //when functions return from their lexical scope they still maintain ther position
    // function x() {
    //   var a = 7;
    //   function y() {
    //     console.log(a); //lexical scoping
    //   }
    //   return y;
    //   // return function y() {
    //   //   console.log(a); //this is same
    //   // };
    // }

    // console.log(x()); //it calls x and get whole y function as value
    // x()();      //same as z
    // var z = x();
    // console.log(z);
    // z();      //now again when z is called it triggers to the same y function

    // function x() {
    //   var a = 7;
    //   function y() {
    //     console.log(a);        //this is same
    //   }
    //   a=100;
    //   return y
    // }
    // x()()

    // function z() {
    //   var b = 900;
    //   function x() {
    //     var a = 7;
    //     function y() {
    //       console.log(a, b); //this is same
    //     }
    //     y();
    //   }
    //   x();
    // }
    // z();

    // function x() {
    //   for (var i = 1; i <= 5; i++) {
    //     function close(i) {
    //       //every time this i creates a new memory refrence
    //       setTimeout(() => {
    //         console.log(i);
    //       }, i * 1000);
    //     }
    //     close(i);
    //     // console.log("Nameste");
    //   }
    // }
    // x();

    //TIMER
    // function startTimer(data) {
    //   for (let index = 0; index <= data; index++) {
    //     setTimeout(() => {
    //       console.log(index);
    //     }, index * 1000);
    //   }
    // }

    // startTimer(5);

    //THIS
    //In the global level this points to window object
    //window is global object which is created along with global execution context

    // FLATTING Array
    // var array = [1, 2, 3, [7, 8, [9]], 4, [5], 6];
    //   var obj={name:"ritik"}
    // function flattenArray(arr) {
    //   var flattened = [];
    //   console.log("flattened",flattened);
    //   arr.forEach(function (item) {
    //     console.log("item", item);
    //     console.log("isArray", Array.isArray(item));
    //     if (Array.isArray(item)) {
    //       flattened = flattened.concat(flattenArray(item));
    //       console.log("flattenedArray",flattened);
    //     } else {
    //       flattened.push(item);
    //     }
    //   });

    //   return flattened;
    // }
    // var flattenedArray = flattenArray(array);
    // console.log(flattenedArray);

    // PALENDROME
    // If first and last chacter are same it's palendrome
    // function checkPalindrome(string) {
    //   console.log("string",string);
    //   console.log("string",string[0]);

    //   const len = string.length;
    //   console.log("len",len);
    //   for (let i = 0; i < len / 2; i++) {
    //     console.log("i : ",i);
    //     console.log("string[i]",string[i]);
    //     console.log("string[len - 1 - i]",string[len - 1 - i]);
    //     if (string[i] !== string[len - 1 - i]) {
    //       return "It is not a palindrome";
    //     }
    //   }
    //   return "It is a palindrome";
    // }
    // const string = prompt("Enter a string: ");
    // const value = checkPalindrome(string);
    // console.log(value);

    //PROMISES
    // AN object there are 3 states of promise object,pending,resolved,rejected
    // resolved .then()
    // rejected .catch()

    // const dwd = new Promise((resolve, reject) => {
    //   let a = 10;
    //   if (a % 2 === 0) {
    //     resolve("resolved");
    //   } else {
    //     reject("rejected");
    //   }
    // });

    // dwd.then((dd) => console.log(dd)).catch((err) => console.log("err", err));

    // const prom = new Promise((resolve, reject) => {
    //   if(true){
    //     return console.log("It is RESOLVED");
    //   }
    //   else console.log("It is Rejected");
    // })

    // const dd = prom.then((re)=>console.log(res)).catch("error")

    // const hell = new Promise((res, rej) => {
    //   if (true) {
    //     console.log("It is RESOLVED");
    //   } else {
    //     console.log("It is REJECTED");
    //   }
    // });

    // hell
    //   .then((res) => console.log(res))
    //   .catch((err) => console.log("err", err));

    // const promise1 = Promise.resolve(123);
    // console.log("promise1", promise1);
    // promise1.then((value) => {
    //   console.log(value);
    // });
    // const resp = new Promise.resolve(123).then((value) => console.log("value"));
    // console.log("resp", resp);

    // const myPromise = new Promise((resolved, rejected) => {
    //   const a = 2;
    //   const b = 12;
    //   const c = a + b;
    //   if (c === 4) {
    //     resolved("yes it's correct ");
    //   } else {
    //     rejected("no it's not");
    //   }
    // });

    // myPromise
    //   .then((data) => {
    //     console.log(data);
    //   })
    //   .catch((err) => {
    //     console.log("err", err);
    //   });

    // promise.race
    // it return the firstly resolved or rejected promise

    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve("one");
    //   }, 500);
    // });

    // const promise2 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve("two");
    //   }, 200);
    // });

    // const promise3 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     reject("It is rejected");
    //   }, 90);
    // });

    // Promise.race([promise1, promise2, promise3])
    //   .then((value) => {
    //     console.log("value", value);
    //   })
    //   .catch((err) => console.log("err", err));

    // promise.all; (All promises should be resolved) [Gives array of values if all promises are resolved and reason if rejected]
    // It takes an iterable of promises as input and returns a new promise
    // that resolves when all the promises in the iterable have resolved successfully. The
    // resolved values of all the promises are collected into an array in the same order as the original promises.
    // It doesn't executes with less sec

    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 1 resolved"), 1000);
    // });

    // const promise2 = new Promise((resolve, reject) => {
    //   setTimeout(() => reject("Promise 2 resolved"), 500);
    // });

    // const promise3 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 3 resolved"), 800);
    // });

    // Promise.all([promise1, promise2, promise3])
    //   .then((results) => {
    //     console.log("All promises resolved:", results);
    //   })
    //   .catch((error) => {
    //     console.log("One of the promises rejected:", error);
    //   });

    // promise.allsettled()
    // gives array of with status key as fulfilled or rejected and value if resolved and reason if rejected
    // It doesn't executes with less sec
    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 1 resolved"), 1000);
    // });

    // const promise2 = new Promise((resolve, reject) => {
    //   setTimeout(() => reject(new Error("Promise 2 rejected")), 500);
    // });

    // const promise3 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 3 resolved"), 800);
    // });

    // Promise.allSettled([promise1, promise2, promise3]).then((results) => {
    //   console.log("All promises settled:", results);
    // });

    // promise.any
    // run all promises untill any one one of is resolved
    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 1 resolved"), 1000);
    // });

    // const promise2 = new Promise((resolve, reject) => {
    //   setTimeout(() => reject(new Error("Promise 2 rejected")), 500);
    // });

    // const promise3 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 3 resolved"), 800);
    // });

    // Promise.any([promise1, promise2, promise3])
    //   .then((result) => {
    //     console.log("At least one promise resolved:", result);
    //   })
    //   .catch((errors) => {
    //     console.log("All promises rejected:", errors);
    //   });

    // const myPromise = new Promise((resolve, reject) => {
    //   if (false) {
    //     resolve("It is true");
    //   } else {
    //     reject("It is false");
    //   }
    // })
    //   .then((resp) => {
    //     console.log("resp", resp);
    //   })
    //   .catch((err) => {
    //     console.log("err", err);
    //   });

    //   console.log(myPromise);

    // Template String
    // const a = "Ritik";
    // const b = "Chauhan";
    // console.log("Welcome to team " + a + ". Hi " + b + "");
    // console.log(`Welcome to team ${a}. Hi ${b}`);

    // Object Dstructuring
    // const details = {
    //   name: "ritik",
    //   age: 22,
    // };

    // const name = details.name;
    // const age = details.age;
    // console.log(name, age);

    // const { name, age } = details;
    // const { name: companyName, age } = details;

    // console.log(name,age);
    // console.log(companyName,age);

    // Array Dstructuring
    // const arr = ["a", "b", "c", "d"];
    // console.log(arr[0]);

    // const arr = ["a", "b", "c", "d"];
    // const [p, q, r, s] = arr;
    // console.log("p : ", p);

    //SPREAD AND REST
    // const oldArr = [1, 2, 3, 4];
    // const newArr = [...oldArr, 2, 3, 4];
    // console.log("newArr", newArr);

    // function sum(a, b, ...numbers) {
    //   console.log(a, b);
    //   console.log("numbers", numbers); //it gather all arguements into a single array
    //   return numbers.reduce((total, num) => total + num, 0);
    // }
    // console.log(sum(1, 2, 3, 4, 5));

    //DIfference between normal function and fat-arrow function
    // function add(a, b) {
    //   return a + b; //no implicit return for single statement
    // }

    // const add = (a, b) => a + b; //implicit return for single statement
    // console.log(add(2, 3));

    // let userInfo={
    //   name:"code Improve",
    //   fullName(){
    //     console.log(this.name + "Normal Function");
    //   },
    //   fullName2:()=>{
    //     console.log(this.name + "Fat Function");      //don't have their own this value
    //   }
    // }

    // console.log("this ", this);
    // let userInfo = {
    //   name: "code Improve",
    //   fullName() {
    //     const name = () => {
    //       console.log(this.name);
    //       console.log(this.name + "Fat Function");    //lexical scoping it found name in parent
    //     };
    //     name();
    //     console.log(this.name + "Normal Function");
    //   },
    //   fullName2: () => {
    //     console.log("this ", this);   //value of this inside a fat-arrow fn is same as otside a fn
    //     console.log(this.name + "Fat Function"); // Arrow functions do not have their own this context. Instead, they capture the value of this from the surrounding scope
    //   },
    // };

    // userInfo.fullName();
    // userInfo.fullName2();

    //Currying:function is transformed into a sequence of functions, each taking a single argument.
    // const multiArgFunction = (a, b, c) => a + b + c;
    // console.log(multiArgFunction(1, 2, 3)); // 6
    // This curried function works by creating closures that capture each argument one by one until all the necessary arguments have been provided

    // const curryUnaryFunction = (a) => (b) => (c) => a + b + c;
    // function curryUnaryFunction(a) {
    //   return function (b) {
    //     return function (c) {
    //       return a + b + c;
    //     };
    //   };
    // }

    // function curryUnaryFunction(a) {
    //   return function (b) {
    //     return function (c) {
    //       return a + b + c;
    //     };
    //   };
    // }
    // console.log(curryUnaryFunction(1)(2)(3));

    // High order function:Ex map, filter, and reduce
    // A higher-order function is a function that accepts another function as an argument or returns a function as a return value or both.

    // function greaterThan(n) {
    //   //greaterThan is a higher-order function because it returns another function.
    //   console.log("n", n);

    //   return (m) => {
    //     console.log("m", m);
    //     m > n ? true : false;
    //   };
    // }

    // let greaterThan10 = greaterThan(10);   //it returns return statement and the this is called with 11 as value
    // console.log("greaterThan10", greaterThan10);
    // console.log(greaterThan10(11)); //greaterThan10 becomes a function generated by greaterThan(10), specifically a function that checks if its input is greater than 10

    // const firstOrderFunc = () =>
    //   console.log("Hello, I am a First order function");
    // function higherOrder(ReturnFirstOrderFunc) {
    //   //A higher-order function is a function that takes one or more functions as arguments or returns a function as its resul
    //   ReturnFirstOrderFunc();
    // }
    // higherOrder(firstOrderFunc);

    // callback function
    // Call back is a function passed as an arguement to another function as an argument which is then invoked inside the outer function
    // to complete some kind of routine or action

    // const students = () => {
    //   const name = "ritik";
    //   return name;
    // };

    // const colleges = (func) => {
    //   return func();
    // };

    // console.log(colleges(students));

    // function tech(args) {
    //   console.log("Teachers called");
    //   setTimeout(() => {
    //     args();
    //   }, 1000);
    // }

    // function students() {
    //   console.log("Students called");
    // }

    // tech(students);

    // function students(arg) {
    //   console.log("students");
    //   setTimeout(() => {
    //     arg();
    //   }, 1000);
    // }

    // function teachers() {
    //   console.log("It's teachers function");
    // }

    // students(teachers);

    // function students(calbck){
    //   console.log("students called");
    //   // calbck();
    //   setTimeout(()=>{
    //     calbck();             //if students delayed

    //   },2000)

    // }
    // function teachers(){
    //   console.log("teachers called");
    // }

    // students(teachers)

    // Pure function (No Side Effects)
    // pure function are function that accept an input and returns a
    // value without modifying any data outside its scope
    // function add(a, b) {
    //   return a + b;
    // }

    // console.log(add(1,2));

    // Example of using the pure function
    // const result = add(3, 5); // Result is always 8
    // console.log(result);

    // const pureFunc = (a, b) => a + b;
    // console.log(pureFunc(2, 6));

    // let result = 0;
    // console.log("resultAbove", result);
    // const impureFunc = (a, b) => {
    //   result = a + b;
    // };
    // impureFunc(3, 8);
    // console.log("result", result);

    // let result = 0; // External state
    // // console.log("result", result);
    // function impureAdd(a, b) {
    //   result = a + b; // Modifies external state
    //   return result;
    // }

    // console.log(impureAdd(2, 3));
    // console.log("result", result);
  </script>

  <body>
    <div>
      <!-- Event Bubbling -->
      <div onclick="alert('First Div')">
        //3
        <div onclick="alert('Second Div')">
          //2 <button onclick="alert('Button alert')">Button</button> //1
        </div>
      </div>
    </div>
  </body>
</html>
<!-- 
type Geeks = {
  name: string;
  age: number;
};

type MoreGeeks = {
  email: string;
};

type CombinedGeeks = Geeks & MoreGeeks;

const gfg: CombinedGeeks = {
  name: "kgowda",
  age: 20,
  email: "kgowda@gmail.com"
};

console.log(gfg); -->

<!-- interface Geeks {
  name: string;
  age: number
}

interface Geeks {
  email: string;
}

// Using the merged interface
const gfg: Geeks = {
  name: &quot; kgowda&quot;,
  age: 20,
  email: &quot; kgowda@gmail.com&quot;
};

console.log(gfg); -->
<!-- Interface support the use of object -->