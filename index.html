<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <script>
      // --------------------------
// [] == [] // false 
// [] !== [] // true 
// ![] == ![] // true 
// !true == [] // true 
// ![] == [] // true 
    // console.log([] == [])
    // console.log([] !== [])
    // console.log(![] == ![])
    // console.log(!true == [])
    // console.log(![] == [])


      // if pay1[item] === pay2[item]
      // As soon as the loop checks the first item and finds that pay1[item] === pay2[item],
      // it will execute the else block and immediately return "Same Payload".
      // This causes the function to stop without fully checking all other key-value pairs.


    //    function samePayload(a, b) {
    //   const aLength = Object.keys(a).length;
    //   const bLength = Object.keys(b).length;
    //   const keys = Object.keys(a);

    //   if (aLength !== bLength) {
    //     return "Not Same";
    //   }

    //   for (let key of keys) {
    //     if (a[key] !== b[key]) {
    //       return "Not Same Keys"; //This Exits the function
    //     }
    //   }

    //   keys.forEach((item)=>{
    //     if(a[item]!==b[item]){
    //       return "Not Same Keys"      // This only exits the callback
    //     }
    //     return "Same Keys"      // This only exits the callback
    //   })
    // }


    // SWAPPING 
    // let a = 66;let b = 9;
    // [a,b] = [b,a];
    // console.log(`A`,a);
    // console.log(`B`,b);


    // FLATTING 
    // const arr = [1,[2,[3,4,5]]]
    // console.log(arr.flat(Infinity));


    //SHUFFLING
    // const arr = [1,2,3,4,5]
    // const shuffleArr = arr.sort(() => Math.random() - 0.5);
    // console.log(shuffleArr);

    // const arr = [1, 2, 3, 4, 5];
    // function shuffle(array) {
    //   for (let i = array.length - 1; i > 0; i--) {
    //     console.log("I---",i);
        
    // // Pick a random index from 0 to i
    //     const j = Math.floor(Math.random() * (i + 1));
    //     // Math.random() gives a number between 0 and 1.
    //     console.log("---------J----------",j);
        
    // // Swap elements at i and j
    //     [array[i], array[j]] = [array[j], array[i]];
    //   }
    //   return array;
    // }
    // console.log(shuffle([...arr]));
    


    

// console.log([] + []);      // ""   (empty string)
// console.log([] + {});      // "[object Object]"
// console.log({} + []);      // 0
// console.log(typeof NaN);    // "number"
// console.log("true" == true);  // false
// console.log(null == undefined); // true
// console.log([] == 0);      // true
// console.log([] == ![]);     // true (what?!)


//       const url = [
//   'https://pokeapi.co/api/v2/pokemon?limit=1',
//   'https://pokeapi.co/api/v2/pokemon?limit=2',
//   'https://pokeapi.co/api/v2/pokemon?limit=3',
//   'https://pokeapi.co/api/v2/pokemon?limit=4',
//   'https://pokeapi.co/api/v2/pokemon?limit=5',
//   'https://pokeapi.co/api/v2/pokemon?limit=6',
//   'https://pokeapi.co/api/v2/pokemon?limit=7',
//   'https://pokeapi.co/api/v2/pokemon?limit=8',
//   'https://pokeapi.co/api/v2/pokemon?limit=9',
//   'https://pokeapi.co/api/v2/pokemon?limit=10'
// ];

// async function getAllData(){
  // try {
  //   const resp = await Promise.all(url.map((item)=>fetch(item)))
  //   const respJSON = await Promise.all(resp.map((item)=>item.json()))
  //   console.log("respJSON",respJSON);
    
  // } catch (error) {
  //   consol.log("error",error)
  // }
// }


// async function getAllData(){
//   await Promise.all(url.map((item)=>fetch(item)))
//   .then(async(resp)=> Promise.all(resp.map((item)=>item.json())))
//   .then((resp)=>console.log("resp",resp))
//   .catch((err)=>console.log("err",err))
// }

// getAllData()

// async function newFunc(){
//   try {
//     const resp = await Promise.all(url.map((item)=>fetch(item)));
//     const respJson = await Promise.all(resp.map((item)=>item.json()))
//     console.log(respJson);
//   } catch (error) {
//     console.log("error",error);
//   }
// }

// newFunc()


    // ------------------------
    // console.log(personInfo.myCallFn(person,"25"));
    // console.log(personInfo.myApplyFunc(person,["25"]));
    // const bindFn = personInfo.myBind(person,"25");
    // bindFn();
    
    


    // myFunction.apply(person,"25")
    // const apply = myFunction.bind(person,"25")
    // console.log(apply());

    // myFunction.call(person,"25")
    // myFunction.apply(person,"25")
    // const apply = myFunction.bind(person,"25")
    // console.log(apply());
    

//     Function.prototype.myCall = function (context, ...args) {
//       //globalThis refers to the global object in any JavaScript environment:
//   context = context || globalThis;
//   const fnSymbol = Symbol(); // avoid name collision
//   context[fnSymbol] = this;
//   const result = context[fnSymbol](...args);
//   delete context[fnSymbol];
//   return result;
// };

// function greet(greeting) {
//   console.log(`${greeting}, ${this.name}`);
// }

// const person = { name: "Ritik" };
// greet.myCall(person, "Hello"); // Hello, Ritik



// Function.prototype.myApply = function (context, args) {
//   context = context || globalThis;
//   const fnSymbol = Symbol();
//   context[fnSymbol] = this;
//   const result = args ? context[fnSymbol](...args) : context[fnSymbol]();
//   delete context[fnSymbol];
//   return result;
// };

// greet.myApply(person, ["Hi"]); // Hi, Ritik


// Function.prototype.myBind = function (context, ...bindArgs) {
//   const fn = this;
//   return function (...callArgs) {
//     return fn.apply(context, [...bindArgs, ...callArgs]);
//   };
// };

// const greetPerson = greet.myBind(person, "Hey");
// greetPerson(); 



// -------------------------------------------

//PRESENT IN ARRAY
// const arr = [10, 20, 30];
// console.log(1 in arr); // true — because index 1 exists (value = 20)
// console.log(5 in arr); // false — index 5 does not exist

// ---------------

    // ==call(), apply(), and bind() are methods used to control the this context of a function.
    // call a function with a specific this value, but they differ in syntax and behavior

    // function helloFunc(args){
    //   console.log(`Hi Mr. ${this.name} chauhan,You are ${args}`);
    // }

    // const person = {name:"Ritik"}
    // helloFunc.call(person,25)
    // helloFunc.apply(person,[25])
    // const bind = helloFunc.bind(person,[25])
    // bind();
    
    

    // CALL : Calls the function immediately && Calls a function with a given this and args
//     function greet(age) {
//       console.log("age",age);
      
//   console.log(`Hello, my name is ${this.name} and I am ${age}`);
// }
// const person = { name: "Ritik" };
// greet.call(person, 25); // Hello, my name is Ritik and I am 25


   // apply : Calls the function immediately && takes arguments as an array
      // greet.apply(person, [25]); 

      // bind : Returns a new function with bound this, doesn't call it immediately
      // const boundGreet = greet.bind(person);
      // console.log(boundGreet);
      
      // boundGreet(25); // Hello, my name is Ritik and I am 25

      // function welcomeFunc(arg){
      //   console.log(`Hi ${this.name}.You are ${arg} old.`)
      // }

      // const person={name:"Ritwik Vats"}

      // Function.prototype.myBindFunc=function(context,...args){
      //   const fn = this;
      //   return function (...props){
      //     fn.apply(context,[...args,...props])
      //   }
      // }

      // const ff = welcomeFunc.myBindFunc(person,21)
      // console.log(ff())

      // Function.prototype.callFunc = function(context,...args){
      //   context = context || globalThis();
      //   const fnSymbolFunc = Symbol();
      //   context[fnSymbolFunc] = this;
      //   const result = context[fnSymbolFunc](...args);
      //   return result
      // }

      // Function.prototype.myApplyFunction = function(context,args){
      //   context = context || globalThis();
      //   const fnSymbolFunc = Symbol();
      //   context[fnSymbolFunc] = this
      //   const result = args ? context[fnSymbolFunc](...args) : context[fnSymbolFunc]()
      //   return result
      // }

      // Function.prototype.myBindFunc = function(context,...args){
      //   const fn = this;
      //   return function(...childArgs){
      //     return fn.apply(context,[...args,...childArgs])
      //   }
      // }

      // const bind = welcomeFunc.myBindFunc(person,[29])
      // bind()
      

      // welcomeFunc.apply(person,[29])
      // const bindFunc = welcomeFunc.bind(person,29)
      // bindFunc();

       // welcomeFunc.call(person,29)
      // welcomeFunc.apply(person,[29])
      // const bindFunc = welcomeFunc.bind(person,29)
      // bindFunc();
      
    // -------------------------------------------------------

    const arr = [1,2,3,4,5]

    // const myMapFunc = arr.map((item)=>item*2);
    // const myFilterFunc = arr.filter((item)=>item%2===0);
    // const myReduceFunc = arr.reduce((x,y)=>x+y,10);
    // console.log(myReduceFunc);

    Array.prototype.myMapFunc = function(calbck){
      const emptyArr = []
      for (let i = 0; i < this.length; i++) {
        emptyArr.push(calbck(this[i],i,this))
      }

      return emptyArr
    }

    Array.prototype.myFilterFunc=function(calbck){
      const emptyArr = []
      for (let i = 0; i < this.length; i++) {
        if(calbck(this[i],i,this)){
          emptyArr.push(this[i])
        }
      }

      return emptyArr
    }

    Array.prototype.myReduceFunc = function(calbck,initialVal){
      const array = this
      let startIndex = 0;
      let accumulator

      if(initialVal!==undefined){
        
      }
    }
    
    // const newArr = arr.myFilterFunc((item,index)=>item%2===0);
    // console.log(newArr);
    


    // Array.prototype.myMap=function(callback){
    //   const emptyArr = [];
    //   for (let i = 0; i < this.length; i++) {
    //     emptyArr.push(callback(this[i],i,this))
    //   }

    //   return emptyArr
    // }

    // Array.prototype.mpMapFunction = function(callBack){
    //   const emptyArr = []
    //   for (let i = 0; i < this.length; i++) {
    //     emptyArr.push(callBack(this[i],i,this))
    //   }

    //   return emptyArr
    // }

    //this refers to the array on which myMap or myFilter is called
//     Array.prototype.myMap = function(callback) {
//   const result = [];
//   console.log("this",this);
//   for (let i = 0; i < this.length; i++) {
//     // Skip empty slots for sparse arrays
//       result.push(callback(this[i], i, this));
//   }
//   return result;
// };



// Array.prototype.myMapFunction=function(callback){
//   const result=[];
//   for (let i = 0; i < this.length; i++) {
//     result.push(callback(this[i],i,this))
//   }

//   return result
// }


// const arr = [1, 2, 3];

// const ee = arr.myMap((it)=>it*2)
// console.log(ee);

// const doubled = arr.myMap(x => x * 2);
// console.log(doubled); 
// --------------------------------------------

// Array.prototype.myFilter = function(callback){
//   const emptyArr = [];
//   for (let i = 0; i < this.length; i++) {
//     if(callback(this[i],i,this)){
//     emptyArr.push(this[i])
//   }
//   }

//   return emptyArr
// }

// Array.prototype.myFilterFunction = function (callBack){
//   const emptyArr = [];
//   for (let i = 0; i < this.length; i++) {
//     if(callBack(this[i],i,this)){
//       emptyArr.push(this[i])
//     }
//   }

//   return emptyArr
// }

// const arr = [1,2,3,4,5];
// const filteredArr = arr.myFilterFunction((item,index)=>item%2===0);
// console.log(filteredArr);


// Array.prototype.myFilter = function(callBack){
//   const emptyArr = []
//   for (let i = 0; i < this.length; i++) {
//     if(callBack(this[i],i,this)){
//       emptyArr.push(this[i])
//     }
//   }
//   return emptyArr
// }
// Array.prototype.myFilter = function(callback) {
//   const result = [];
//   for (let i = 0; i < this.length; i++) {
//     // Skip empty slots
//       if (callback(this[i], i, this)) {
//         result.push(this[i]);
//       }
//   }
//   return result;
// };

// const nums = [1, 2, 3, 4, 5];
// const arrt = nums.myFilter((it)=>it%2===0)
// console.log(arrt);

// const evens = nums.myFilter(n => n % 2 === 0);
// console.log(evens);


// // --------------------------------------

// Array.prototype.myReduce = function(callback, initialValue) {
//   if (typeof callback !== "function") {
//     throw new TypeError(callback + " is not a function");
//   }

//   const array = this;
//   let accumulator;
//   let startIndex = 0;

//   // Handle initialValue
//   if (initialValue !== undefined) {
//     accumulator = initialValue;
//   } else {
//     // Find first defined value for sparse arrays
//     while (startIndex < array.length && !(startIndex in array)) {
//       startIndex++;
//     }

//     if (startIndex >= array.length) {
//       throw new TypeError("Reduce of empty array with no initial value");
//     }

//     accumulator = array[startIndex];
//     startIndex++;
//   }

//   // Iterate over the array
//   for (let i = startIndex; i < array.length; i++) {
//     if (i in array) {
//       accumulator = callback(accumulator, array[i], i, array);
//     }
//   }

//   return accumulator;
// };


// --------------

// Array.prototype.myReduceFunction = function(callBack,initialValue){
//   const array = this;
//   let accumulator;
//   let startIndex=0

//   if(initialValue!==undefined){
//     accumulator = initialValue
//   }
//   else{
//     while(startIndex<array.length && !(startIndex in array)){
//       startIndex++
//     }

//     if(startIndex>=array.length){
//       throw new Error("Error");
//     }

//     accumulator = array[startIndex];
//     startIndex++
//   }

//   for (let i = 0; i < array.length; i++) {
//     if(i in array){
//       accumulator = callBack(accumulator,array[i],i,array)
//     }
    
//   }

//   return accumulator
// }

//--------------------------------------
    // const arr = [10, 20, 30, 40, 50]
    
    // const arr = [10, 20, 30, 40, 50];
    // function sumAll(data){
    //   let sum = 0
    //   // for (let i = 0; i <= data.length; i++)     //When i = 5 → data[5] = undefined
    //   for (let i = 0; i < data.length; i++) {
    //     sum = data[i] + sum     //and undefined + sum = NAN
    //   }
    //   // data.forEach(element => {
    //   //   sum+=element
    //   // });
    //   return sum
    // }

    // console.log(sumAll(arr));

    // const suMFunc=(data)=>{
    //   let sum= 0
    //   for (let i = 0; i < data.length; i++) {
    //     sum+=data[i]
    //   }
    //   console.log(sum);
    //   return sum
    // }
    // console.log(suMFunc(arr));


    // -----------------------------------




//->Only copies the first level of an object or array.
//->Nested objects or arrays are still referenced 
// =>So name remain unchanged but city changes
  // const original = {
  //   name: "Ritik",
  //   address: { city: "Delhi" },
  // };

  // const shallowCopy = { ...original };

  // shallowCopy.name = "Chauhan";
  // shallowCopy.address.city = "Mumbai";

  // console.log(original.name); // Ritik ❌→ Chauhan (not affected)
  // console.log(original.address.city);

// ----------

// Creates a true copy of the entire structure, including nested objects/arrays.
// Changes made in the copy won’t affect the original.


// const original = {
//   name: "John",
//   address: {
//     city: "Delhi"
//   }
// };

// // // Deep clone using JSON (works only for simple objects)
// const deepClone = JSON.parse(JSON.stringify(original));

// deepClone.address.city = "Mumbai";
// deepClone.name = "RitikChauhan";

// console.log(original.address.city); 
// console.log(original.name);

// console.log(deepClone.address.city); 
// console.log(deepClone.name); 

// --------

    //Optional chaining is only allowed when accessing values, not when assigning to them.
    //You cannot assign to something that might be undefined – it defeats the purpose of assignment safety.
    // error : Support for the experimental syntax 'optionalChainingAssign' isn't currently enabled

    // const x = obj?.prop; // ✅ valid
    // obj?.prop = 123;     // ❌ invalid

  // const handleChange = (e) => {
  //   const { name, value } = e.target;
  //   setUser((prev) => ({
  //     ...prev,
  //     [name]: value,    //they're using a JavaScript feature called "computed property names
  //   }));
  // };
  //Without the brackets, it would literally create a key named "name" for email like 
//   {
//   name: "user@example.com"
// }


//Instead of hardcoding a property name, you compute it at runtime using square brackets
// const key = "email";
// const obj = {
//   [key]: "example@example.com"
// };
// console.log(obj);

// const obj = {
//   key: "example@example.com"
// };
// console.log(obj); // { key: "example@example.com" } ❌ Not dynamic

// -------------------------------------------------

// var Hoisting
// console.log(x); // undefined (NOT ReferenceError)
// var x = 5;

// // Internally JS does:
// var x;         // declaration hoisted
// console.log(x); // undefined
// x = 5;         // initialization

//  Temporal Dead Zone (TDZ)
// The Temporal Dead Zone is the time between hoisting and declaration where accessing a let or const variable causes a ReferenceError.
// a is hoisted but not initialized.
// console.log(a); // ❌ ReferenceError
// let a = 20;

// ---------------------------------------------------------

    // A variable is not defined if you try to use it without declaring it first.
    // console.log(x); // ❌ ReferenceError: x is not defined

// let x;       //A variable is declared but not assigned a value
// console.log(x); // undefined

// function test() {}     // A function doesn’t return anything.
// console.log(test()); // undefined

// let obj = {};
// console.log(obj.key);

// let a;
// console.log(a);        // undefined
// console.log(b);        // ❌ ReferenceError: b is not defined

// --------------------

// console.log('Start');
// setTimeout(() => {
//   console.log('Macrotask - setTimeout');
// }, 0);
// Promise.resolve().then(() => {
//   console.log('Microtask - Promise');
// });
// console.log('End');

// Start
// End
// Microtask - Promise (High-priority tasks, run immediately after the current execution context and before any rendering)
// Macrotask - setTimeout

// const user = {username:"Ritik"}
// const key = [[[["username"]]]]  //When arrays are used as keys or property accessors, JavaScript coerces them to strings using .toString().
// console.log(user[key]);   //JavaScript implicitly converts the array to a string
// key == [[[["username"]]]] → becomes "username" (because of array to string coercion)
// console.log([[["username"]]].toString());

    // console.log([]+{})    //"" + "[object Object]" → "[object Object]"
    // console.log({} + [])

    // output.forEach(async (item) => {
    //   await assignToUser(item.mandate_id, code, item.rating_process_uuid);
    // });

    // for (const item of output) {//It waits for each assignToUser() call to complete before going to the next item.
    // await assignToUser(item.mandate_id, code, item.rating_process_uuid);
    //   }
    //for...of with await runs each assignToUser() call sequentially, waiting for each one to finish.
    // Always use for...of (or for, while) when you need to use await inside a loop and want it to actually wait.

  // .forEach() doesn't wait for async callbacks.
  //So even though you're using await inside the callback, the outer function doesn't pause for them to finish.

//   const items = [1, 2, 3];

// items.forEach(async (item) => {
//   await new Promise((resolve) => setTimeout(resolve, 1000));    //it didn't wait for 1 sec
//   console.log(item);
// });

// console.log("Done");
// `


// const items = [1, 2, 3];

// async function processItems() {
//   for (const item of items) {
//     await new Promise((resolve) => setTimeout(resolve, 1000));   //it waits for 1 sec
//     console.log(item);
//   }
// }
// console.log("Done");

// processItems();
    
    // FOR IN
    // Note : Use array notation in forin and forof loops to get a value
    // const obj = { a: 1, b: 2, c: 3 }

    // for (const key in obj) {
    //   console.log(key);
    //   console.log(obj[key]);
    // }

    // for (const key in obj) {
    //   console.log(obj[key]);
    // }

    // const keys = Object.keys(obj)
    // const values = Object.values(obj)
    // console.log("KEYS",keys);
    // console.log("VALUES",values);

    // for (let key in obj) {
    //   console.log("key",key); // Output: 'a', 'b', 'c'
    //   console.log("value",obj[key]); // Output: 1, 2, 3
    // }

    // // FOR OF
    // const arr = [1, 2,8, 3];

    // for (const element of arr) {
      // console.log(element);
      // console.log(arr[element]);  //arr[1],arr[2],arr[8]
    // }

    // for (const element of arr) {
    //   console.log(element);
    // }

    // for (let value of arr) {
    //   console.log(value); // Output: 1, 2, 3
    // }


    // const [key,value] = [["firstName","John"],["lastName","Doe"],["age",30],["arr",["John","qwe"]]]
    //   console.log("key",key);
    //   console.log("value",value);

    // const person = {
    //   firstName: "John",
    //   lastName: "Doe",
    //   age: 30,
    //   arr: ["John", "qwe"],
    // };

    // for (const [key,value] of Object.entries(person)) {
    //   console.log("key",key);
    //   console.log("value",value);
    // }

    // for (const [key,value] of Object.entries(person)) {
    //   console.log("key",key);
    //   console.log("value",value);
    // }


    // console.log(Object.entries(person)); //it creates array of arrays containing keys and values  
    // console.log(Object.keys(person));
    // console.log(Object.values(person));
    // for (const [key,value] of Object.entries(person)) {  //to extract keys and values [arrValue1,arrValue2] = [1,2]
    //   // const [key,value] = [["firstName","John"],["lastName","Doe"],["age",30],["arr",["John","qwe"]]]
    //   console.log("key",key);
    //   console.log("value",value);
    // }
    // for (const data of Object.entries(person)) {
    //   console.log("data",data);
    // }

    // Note:

    // check if they both contains same items or not
    // const a = [1, 2, 3];
    // const b = [1, 3, 2];

    // const ascendingsort = (arr)=>{
    //     const newArr = [...arr]; // make a copy to avoid mutating the original
    //     for (let i = 0; i < newArr.length; i++) {
    //       console.log("IIIIII Value",newArr[i]);
    //       for (let j = 0; j < newArr.length - 1 - i; j++) {
    //         console.log("first Value",newArr[j]);
    //         console.log("---second---",newArr[j+1]);
    //         if(newArr[j] > newArr[j+1]){ 
    //         const emptyArr = newArr[j]
    //         newArr[j] = newArr[j+1]
    //         newArr[j+1] = emptyArr
    //       }
    //     }
    //   }
    //   return newArr
    // } 

    // console.log(ascendingsort(b));
    
    // const equalItem = a.length === b.length && a.every((item)=>b.includes(item))
    // const conditioon = a.length === b.length && a.every((item)=>b.includes(item))

    // console.log("equalItem",equalItem);
    

    // console.log(conditioon);
    

    // console.log(b.sort().reverse(  ));
    
    // const sameItems = (obj1,obj2)=>{
    //   if(obj1?.length !== obj2.length){
    //     return "Not same"
    //   }
    //   // const dd =obj1.every((it)=>obj2.includes(it))
    //   const dd =   JSON.stringify(obj1.sort()) === JSON.stringify(obj2.sort())
    //   return dd ? "Same" : "Not same"
    // }

    // console.log("ss",sameItems(a,b));

    // const check = a.every((item)=>b.includes(item));
    // console.log(check);

    // const sameArr = a.length === b.length && a.every((item)=>b.includes(item))
    // console.log("sameArr",sameArr);

    // NOTE : null equals to null or undefined
    // console.log(null===null);
    // console.log(null===undefined);
    // console.log(null==undefined);
    // console.log(typeof(null));
    // console.log(typeof(undefined));   //undefined
    // console.log(null == 0);
    // console.log(null == '');

    //Type Coercion
    // Numeric to String Coercion:
    // var num = 42;
    // var str = "The answer is " +  num; // Coercion: number to string
    // console.log(str); // Output: "The answer is 42"
    // console.log(typeof str);

    // String to Numeric Coercion:
    // var str = "jh42s";
    // var str = "42";
    // var num = +str; // Coercion: string to number
    // console.log(num);
    // console.log(typeof num); // Output: 42

    //When an operation like subtraction (-), multiplication (*), division (/), or modulus (%) not (+) is performed, all the values that are not numbers are converted into the number data type
    // console.log(10 % "5")
    // console.log(10 / "5")
    // let cc = 10 % "5"
    // let cc = 10 / "5"
    // console.log(typeof(cc));
    // console.log("number" + 15 + 3)  //+ has left-to-right associativity, so expression "number" + 15
    // console.log(15 + 3 + "number" )
    // console.log(15 + 3 + +"number" )
    //Boolean to Number
    // console.log(false + 2); //converts false to 0 and then 0 + 2
    // console.log(Number(null));
    // console.log(Number(undefined));   //Its NAN
    // https://www.freecodecamp.org/news/js-type-coercion-explained-27ba3d9a2839

    // Comparison Coercion:(== , !=) converts string to number (ONLY ==)
    // comparison operators (>, <, <=,>=)
    // bitwise operators ( | & ^ ~)
    // console.log('true' == true);  //== operator triggers numeric conversion,;'true' is converted to number i.e, to NaN and true is 1
    // console.log(42 == "42");  //In this case, the loose equality operator == coerces the string "42" into a number before comparing it with the number 42.
    // console.log([]=="");
    // console.log([]==![]);   //here ![] == false then "" == ""    //![] = 0
    // !coverts it to boolean(false) JavaScript attempts to convert the operands to the same type.
    // "" == 0    //type coercion if the operands are of different types
    //0 == 0    //again coercion
    // console.log(true + "10"); // Boolean TO STRING The Boolean value true is converted to string 'true'
    // console.log("10" + true);
    // console.log(true + +"10");
    // console.log(true + 10); //Boolean To NUMBER
    // console.log(12 / "6"); //Arithmetic division operator / triggers numeric (12/6)
    // console.log([1] > null);      //Comparison operator triggers numeric conversion  null will become 0
    // console.log(!!"false" == !!"true"); //sinnce they are non-empty strings so both are true
    // console.log(['x'] == 'x');    //Array’s toString() converts ['x'] to just 'x' string.
    // console.log([] + null + 1);   //empty array in ""
    // console.log(3 > 2 >= 1);    //true
    // console.log(3 > 2 > 1);    //false as 1>1
    // console.log(1 > 2 > 3); //false non-numeric value to a number
    // console.log(2 > 1 > 0); //true non-numeric value to a number
    // console.log("%cHello World","color:yellow");
    // console.log("%cThis is a red text", "color:red");
    // const person = {
    //   name: "batMan",
    //   age: 21,
    // };
    // console.log(Object.entries(person))
    // for (const [key,array] of Object.entries(person)) {
    //   console.log("key",key);
    //   console.log("array",array);
    // }
    // console.log(Object.keys(person)); //gives array of keys
    // console.log(Object.values(person)); //gives array of values
    // for (const item in person) {
    //   //it will give keys of object
    //   console.log(item);
    //   console.log(person[item]);
    // }

    // const obj = { 1: "a", name: "b", 3: "c" }; //we can define an obj key as an number but not var,let name
    // console.log(obj.hasOwnProperty("1")); //you can use that number as string or number it works for
    // console.log(obj.hasOwnProperty("name")); //both
    // console.log(Object.keys(obj).length);
    // console.log("obj", obj);

    // const arr = [10, 10, 10, 10, 10, 10,].map(parseInt); //parseInt("10", 1) The radix is 1, which is not a valid radix. Therefore, NaN is returned.
    // console.log(arr); //parseInt("10", 2) is called. The radix is 2, so "10" is interpreted as a binary number, and the result is 2

    // It's due to different scopes of both the variables
    // var num = 8; //memory allocated to num variable with a variable
    // function display() {
    //   //memory allocated to display()
    //   num = 10;
    //   console.log(num);
    // }
    // display(); //function is called
    // console.log(num);

    // var num = 8;
    // function display() {
    //   var num = 10;
    //   console.log(num);
    // }
    // display();
    // console.log(num);

    // console.log("2" * "8")    //multiplication operator (*) implicitly converts the string values to numbers before performing the multiplication.
    // console.log(2 + "4" * "2")  	  //BODMAS ; When + is used with -,* etc
    // console.log(1 + +"1");
    // console.log(1 + "1");
    // console.log("1" + "1" - 1);
    // console.log("1" + "1" + 1);
    // console.log("2" > "12"); //in lexicographical order ,The comparison starts with the first characters of the two strings: "2" and "1".
    // console.log("2" > "32");
    // console.log(2 > 12);
    // console.log("2" > 12);
    // console.log(String([1, 2, 3])); //to convert array to string //String([1,2,3]) → calls [1,2,3].toString() → which returns "1,2,3"
    // console.log(...[1, 2, 3]); //It does not convert the array to a string — it unpacks its items. //Logs them as individual arguments
    // console.log([1,2,3].toString());
    // console.log(1+ [1,2,3]);    //Array to string conversion ; [1, 2, 3].toString() → "1,2,3" //String(1) + "1,2,3" → "1" + "1,2,3" → "11,2,3"
    // console.log("17"+ [1,2,3]);
    // const ab = [1, 2, 3].join('') //becomes string
    // console.log(ab,typeof ab);
    // console.log(1 + [1, 2, 3].join(''))
    // console.log([1,2,3] + [4,5,6]);     //+ operator with arrays, it performs array-to-string
    // console.log(!true-true);
    // console.log(true + "10");    //Boolean to string
    // console.log(true + 10);      //Boolean to number
    // console.log(true + +"10");

    // NOTE : sort and splice affects main/orignal array
    // null : It is often used as a placeholder or to indicate that a variable or property has no assigned value.
    // let variable=null;
    // console.log(variable);
    // undefined : is a primitive datatype that is automatically assigned to variables that has been declared but not initialized any value.
    // let variable;
    // console.log(variable);

    // 1. Operations in javascript are performed from left to right
    // 2. If we add + sign in front of string(+"8") it become number
    // 3. delete return true or false;it only deletes(key value) property not obj.
    // 4. if we delete Array index then it deletes it and write empty there
    // 5. Set removes duplicay from array [...new Set(array)]
    // 6. a=[] ...a makes array element out removing , (array to string conversion)
    // console.log(...[1,2]);
    // const a=[1,2,3] // {...a} makes array of object with index as keys
    // console.log({...a});
    // console.log({a});
    
    // console.log(1+[1,2]);
    // console.log("1"+[1,2]);
    // 11. spread before array func(...[1,2]) converts it into string
    // console.log([..."anil"]);                 //it will break string and make it an array of string
    // console.log(..."anil");           //it make character out of string seperately
    // console.log(...['anil','hi']);
    // console.log(['anil','hi'].toString())
    // 7. ex=true || false && false;
    // console.log(true || true && console.log("1"));
    // console.log(true || true && 10);
    // 8. bCondition1 && bCondition2 is same !(!bCondition1 || !bCondition2)
    // console.log(A || B);                     // true
// console.log(!(!A && !B));   
    // 9. FALSE  =  null ; NaN ; 0 ; empty string ("" or '' or ``) ; undefined.
    // console.log(Boolean({}))
    // 10. nullish operator (??) returns its right-hand side operand when its left-hand
    //  side operand is null or undefined, and otherwise returns its left-hand side operand.
    // 12.During event propagation, there are 3 phases: capturing, target, and bubbling.The deepest
    //  nested element that caused the event is the target of the event.
    //  You can stop bubbling by event.stopPropagation.
    // NOTE:If we click p, we see two logs: p and div.
    // NOTE:typeof null returns "object"
    // 13. here are 8 falsy values: undefined, null, NaN, false, '' (empty string), 0, -0, 0n (BigInt(0))
    // 14. Primitive types are boolean, null, undefined, bigint, number, string, and symbol.
    // 15. 15/2 = Q:7
    // 16. 15%2 = R:1
    // 17. += concatinate and assign
    // >=
    // console.log(3+4+'6');
    // console.log(typeof 3+4+'6');        //o/p are performed from left to right,   'number' + 4 + '6'
    // console.log(typeof (3+4+'6'));    //The parentheses (3 + 4 + '6') force the expression inside to be evaluated first
    // let data = 3 + 4 + "5";
    // console.log(data);
    // console.log(typeof data);

    // let abs = { name: "ritik", age: 12, skill: "rosk" };
    // console.log([abs]);
    // console.log(...[abs]);
    // console.log(...abs);      //Spread syntax requires ...iterable
    // console.log("hi" || (false && false));   //  return true

    // let abs = [{ name: "ritik" }, { age: 12 }, { skill: "rosk" }];
    // console.log(...[abs]);
    // console.log([...abs]);
    // console.log(...abs);
    // console.log({ abs });
    // console.log([ abs ]);

    // const mySet = new Set();

// mySet.add(1);
// mySet.add(2);
// mySet.add(2); // duplicate, ignored
// console.log(mySet); // Set(2) {1, 2}
// console.log([...mySet]);

    // let arr=["js","react","vscode"]
    // let arr = [1, 7, 2, 6, 3, 4];
    // const arrs=arr.push("c#","234")      //pushed item in last of array
    // console.log(arrs);    //gives count on no of elements
    // const arrs = arr.unshift("c++","123")      //pushed item in first of array
    // const arrs = arr.pop()              //delete item in last of array and returns that deleted item
    // const arrs = arr.shift()              //delete item in first of array and returns that deleted item
    // const arrs = arr.splice(1,1)
    // const arrs = arr.fill(1)               //fill every element with one
    // const arrs=arr.reverse()               //reverse array
    // console.log(arrs);    //gives reversed array
    // let newArr = arr.map((item) => item * 2); //returns new array with updated values and doesn't affect previous array
    // let newArr=arr.includes(1);        //returns true or false if condition matches
    // let newArr = arr.filter((item,index,array) => {   //return true condition only
      // console.log(item);
      // console.log(index);
      // console.log(array);
      // return item !== 2
    // }); //returns new array with filtered values, it removes the element whose condition becomes false
    // let newArr = arr.filter((item) => item === 2); //if condition is true it takes it out that item
    // let newArr=arr.find((item)=>item>2);     //returns only(7) first array value after condition matches
    // let newArr = arr.some((item) => item > 3); //returns true if either one codition satisfies
    // let newArr = arr.every((item) => item > 3); //returns true when all the codition satisfies i.e, all items must be greater than 3
    // let newArr = arr.findIndex((item) => item === 3); //returns index if condition matches if not matches returns (-1)
    // const fruits = ["apple", "banana", "orange", "banana", "grape"];
    // const bananaIndex = fruits.indexOf("banana");
    // console.log(bananaIndex);
    // let newArr = arr.reduce((prev, curr) => {
    //   //prev is what what you give in dependency
    //   console.log("prev", prev);
    //   console.log("curr", curr);
    //   return prev + curr;
    // }, 0); //gives sum of all numbers

    // const arr = [10, 20, 30, 40, 50];
    // function sumAll(data){
    //   let sum = 0
    //   for (let i = 0; i < data.length; i++) {
    //     sum = data[i] + sum
    //   }
    //   // data.forEach(element => {
    //   //   sum+=element
    //   // });
    //   return sum
    // }

    // console.log(sumAll(arr));
    

    // let newArr = arr.reduce((prev, curr) => {
    //   return prev + curr;
    // }, 0); //gives sum of all numbers

    // initially prev is 0 and curr[0] is 1 then prev is added value and prev is 1,initialValue is 0

    // function ssuumm(data) {
    //   let sum = 0;
    //   data.forEach((element) => {
    //     sum += element;
    //   });
    //   return sum;
    // }

    // function ssuumm() {
    //   let s = 0;
    //   arr.forEach((ele) => (s += ele));
    //   return s
    // }

    // console.log(ssuumm(arr));

    // function sum(data){
    //   let s = 0;
    //   data.forEach(element => {
    //     s += element
    //   });
    //   console.log("s",s);
    //   return s
    // }

    // console.log(sum(arr));

    // let newArr = arr.join("+");       //convert array into string with + seperated
    // let newArr = arr.toString();          //convert array into string with , seperated
    // console.log(...arr);    //make array elements out w/o , seperation
    // console.log("hello", ...arr.join("/"));      //iterates without , seperation
    // console.log("hello", arr.join("/"));
    // const newArr = arr.splice(3,0,"i","p");          //add 2(inclusive) no on 3nd index and dont' remove any ahead elemnet
    // let newArr=arr.slice(0,3);  //Slice from the 1st element to the 3rd element (non-inclusive means delete 3rd index also):         //deletes array element of given index  (Extract elements from index 0 (inclusive) to index 3 (exclusive))
    // let newArr=arr.slice(1,3);    //Slice from the 2nd element to the 4th element (non-inclusive 1 and delete ahead indexes inclusive 3):
    // let newArr=arr.sort();          //sort no alphabetically;; affect main arr
    // let newArr=arr.sort().reverse();          //sort no alphabetically;; affect main arr    
    // console.log("newArr", newArr);
    // console.log("arr", arr);

    //extract a section of an array and return a new array.(SLICE) It doesn't modify the orignal array
    // NOTE:If the start index is greater than or equal to the end index, it returns an empty array.
    // var originalArray = [1, 2, 3, 4, 5];
    // var portion = originalArray.slice();
    // var portion = originalArray.slice(6, 3);
    // var portion = originalArray.slice(4, 3);
    // var portion = originalArray.slice(3, 3);
    // ***var portion = originalArray.slice(3, 1);    //as start index is greater than end index
    // var portion = originalArray.slice(1, 4); //This extracts elements from index 1 to (4-1) = 3. The resulting portion array will be [2, 3, 4].
    // var portion = originalArray.slice(2, 4);      //4-1 means 3rd index
    // var portion = originalArray.slice(0, 4);      //array will include elements from index 0 to 4 - 1 = 3, resulting in [1, 2, 3, 4].
    // var portion = originalArray.slice(2);       //This extracts elements starting from index 2 to the end of the array. The resulting copyToEnd array will be [3, 4, 5].
    // var portion = originalArray.slice(-4);        // (-3-1 = 2index) This extracts the last three elements of the array, regardless of the array's length.
    // var portion = originalArray.slice(-3,4);
    // var portion = originalArray.slice(-3,-1);
    // var portion = originalArray.slice(-1,-3);
    // console.log("originalArray", originalArray);
    // console.log("portion", portion);

    //(SPLICE)It modifies the array it's called on and (laster no - 1)
    //  **returns an array containing the deleted elements;
    // return empty [] array with added values
    // var array = [1, 2, 3, 4, 5, 6, 2];
    // var removed = array.splice(2, 2); //removes two elements starting from index 2(start from index inclusive means delete it also).
    // var addArr = array.splice(2, 0, 6, 7);    //inserts 6 and 7 at index 2(start from index inclusive means add at it place also) without removing any elements.
    // var removed = array.splice(0, 2);     //(2-1=1index)start from index 0 and remove elements upto 2 index(non inclusive means don't delete second index element)
    // var removed = array.splice(-2);     //When you use a negative index with splice, it starts counting from the end of the array. In this case, -1 refers to the last element, and -2 refers to the second-to-last element
    // var removed = array.splice(-3, 2);
    // (-2-1=1index)starting from last index to -2 index means delete elements from last index to -2 index(not - inclusive means don't delete -2 index element)
    // var removed = array.splice(2, 1, 'a');       //add a and b
    // var removed = array.splice(2, 0, 'a');
    // var adding = array.splice(array.length, 0, 6, 7); //add 6 and 7 at the last of array
    // var adding = array.splice(100, 0, 6, 7); //add 6 and 7 at the last of array
    // console.log("array", array); //it is modified array,array is now [1, 2, 5]
    // console.log("addArr", addArr); //it gives deleted values,removed is [3, 4]
    // console.log("removed", removed); //adding array element give empty array
    // console.log("adding", adding);
    // console.log("array", array);

    // let arr = [1, 2, 3, 4]; //returns (undefined )it doesn't give new array instead it modifies the orignal array
    // const newArr = arr.forEach((element, index, array) => {
    //   //not need to return anything as we are manipulating array elements
    //   console.log("element", element); //array elements
    //   console.log("index", index);
    //   console.log("array", array); //full array arr changes again and again

    //   array[index] = element * 2;
    //   return "true"
    // });
    // console.log(arr);
    // console.log(newArr);

    // NOte :: Saving in other variable gives you deleted things

    // let a = ["1", "2", "3", "4"];
    // let b = ["6", "7", "3", "2"];

    // const fil = a.concat(b.filter((item)=>!a.includes(item)))
    // console.log("fil",fil);
    

    // const sds= a.concat(b.filter((item,index)=>!a.includes(item)));
    // const sds = b.filter((it,ind)=>!a.includes(it));
    // console.log("sds",sds);

    // const c = a.concat(b);
    // console.log("c",c);
    // const daata = c.filter((item,index)=>c.indexOf(item)===index);
    // const daata = c.filter((item,index)=>b.includes(item));
    // console.log(daata);

    // const c = [...a, ...b];
    // const arr = c.filter((it, index) => c.indexOf(it) === index);
    // console.log("arr", arr);

    // console.log([...new Set(c)]);
    // const ff = a.concat(b.filter((item, index) => !a.includes(item)));
    // console.log("ff", ff);

    // const arr = c.filter((item, ind) => c.indexOf(item) === ind);
    // console.log(arr);
    // const filtt = a.concat(b.filter((item) => !a.includes(item)));
    // console.log("filtt", filtt);

    // const arrs = [1, 2, 3, 4, 5, 7, 2, 1, 5];
    // const ff = arrs.filter(
    //   // (item, index) => arrs.findIndex((it) => it === item) === index
    //   (item, index) => arrs.indexOf(item) === index
    // );
    // console.log("ff", ff);

    // const ff = arrs.filter((item, index) => arrs.indexOf(item)===index);
    // const ff = arrs.filter(
    //   (item, index) => arrs.findIndex((it) => it === item) === index
    // );

    // console.log("ff", ff);

    //   const arr = b.filter((it)=>!a.includes(it));
    //   console.log("arr",a.concat(arr));

    //  const total = [...a, ...b];
    // console.log("total", total);
    // console.log(new Set(total)); //it gives an obj
    // //  console.log(new Set(total)); //spreading obj remove , and give element
    //  console.log([...new Set(total)]); //is to make array

    // let mergedUnique = a.concat(b.filter(item => !a.includes(item)));
    // console.log("Merged Array with Unique Values:", mergedUnique);
    // let mergedUnique = [...new Set([...a, ...b])];
    // console.log("Merged Array with Unique Values:", mergedUnique);

    //  result = "foo" && 4; // result is assigned 4, if both true it returns right side
    //  result = "" && "foo"; // result is assigned "" (empty string)
    //  result = "foo" && "";
    //  a8 = "Cat" && "Dog"; // t && t returns "Dog";both true returns right side
    //  a8 = "" && false; // both false returns "" , returns left side
    //  a8 = false && "";
    // let result = "foo"  || 4;          // result is assigned 4, if both true it returns right side
    //  result = "" || "foo";          // result is assigned foo
    //  result = "foo" && "";      // result is assigned "" (empty string)
    //  a8 = "Cat" || "Dog";           // t && t returns "Dog";both true returns right side
    //  a8 = false || null;        	    //return right side if both false
    //  a8= false || '' || null;
    //  console.log("a8",a8);
    //  console.log("result",result);
//     console.log(+[1,2,3]); 
//     console.log(+{}); 
//     console.log(5 + !5); // 5 + false → 5 + 0 = 5
// console.log(5 + !0); // 5 + true  → 5 + 1 = 6
// console.log([] + []);         // "" → empty string
// console.log([] + {});         // "[object Object]"
// console.log({} + []);

    // const foo = (null) ?? "default string"; //if 1st condition is null or undefined it returns right side
    // console.log(foo); //else it returns left condition

    // const baz = 0 ?? 42;      //as 0 is not null or undefined
    // console.log(baz);

    // function getAge(...args) {
    //   console.log(args); //spread operator makes it an array
    //   console.log(...args);
    //   console.log(typeof args); //type of arguement is object
    // }
    // getAge(21);

    // for (var i = 0; i < 3; i++) {        //it only updates one key, captures the variable i by reference
    //   console.log(i);
    //   setTimeout(() => console.log(i), 2000);
    // }

    // now it's in global scope and behaves like var
    // let i
    // for ( i = 0; i < 3; i++) {     //it creates 3 lets
    //   console.log(i);
    //   setTimeout(() => console.log(i), 1);
    // }

    // let radius = 11;
    // const shape = {
    //   radius: 10,
    //   diameter() {
    //     // return radius * 1;
    //     return this.radius * 2; //with regular function this keyword refers to its current surrounding scope,
    //   }, //example shape object
    //   perimeter: () => 2 * radius, //fat arrow fun doesn't refer to the shape object,it's
    // }; //surrounding scope is window for example
    // they inherit the this value from the enclosing function or context but it's a object.
    // , it doesn't refer to the shape object's radius, but rather it refers to the radius variable in the outer scope

    // console.log(shape.diameter());
    // console.log(shape.perimeter());

    // Getting key from OBJECT by DOT method and by ARRAY Method
    // const bird = {
    //   size: "small",
    // };

    // const propertyName = "size";
    // console.log(bird[propertyName]); // Accessing the property using a variable
    // console.log(bird.propertyName); //undefined

    // const book = {
    //   "title with spaces": "JavaScript Guide",
    //   "year published": 2022,
    // };

    // console.log(book["title with spaces"]); // Output: JavaScript Guide
    // console.log(book.title with spaces);

    // const bird = {
    //   size: "small",
    // };
    // const mouse = {
    //   name: "Mickey",
    //   small: true,
    // };

    // console.log(mouse[bird.size]);
    // console.log(mouse[bird["size"]]);

    // let c = { greeting: "Hey!" };
    // let d;
    // d = c;
    // console.log(d === c);
    // c.greeting = "Hello"; //you change one object, you change all of them
    // console.log(d.greeting); //as c and d have same reference

    // console.log(new Number(3) == 3); //it's an object whose value is 3
    // console.log(typeof new Number(3));

    // function getPersonInfo(one, two, three) {
    //   console.log(one); //tagged template literals, the value of the first argument is                                    // always an array of the string of empty values
    //   console.log(two); //The remaining arguments get the values of the passed expressions
    //   console.log(three);
    // }
    // const person = "Lydia";
    // const age = 21;
    // getPersonInfo`2344  cc ${person} is cvdfg df ${age} years old`;

    // function checkAge(data) {
    //   if (data === { age: 18 }) {
    //     //The two objects that we are comparing don't have tha
    //     console.log("You are an adult!"); //t: the object we passed as a parameter refers to a different location in memory
    //   } else if (data == { age: 18 }) {
    //     console.log("You are still an adult.");
    //   } else {
    //     console.log(`Hmm.. You don't have an age I guess`);
    //   }
    // }
    // checkAge({ age: 18 });

    // function getAge(...args) {
    //   console.log(args);
    //   console.log(...args);
    //   console.log(typeof args);
    //   console.log(typeof []);
    // }
    // getAge(21);

    // function getAge(...args) {
    //   console.log(args);
    //   console.log(...args);
    //   console.log(typeof args);
    //   console.log(typeof []);
    // }
    // getAge([21,22]);

    // let a=[];
    // let b=[];
    // console.log(a==b);     //when we compare 2 array it actually compare its memory location
    // console.log(a===b);

    // let a=[];
    // let b=a;
    // console.log(a==b);
    // console.log(a===b);

    // let a=[20];
    // let b=[20];
    // console.log(a[0]==b[0]);       //we specified element so value will be compared
    // console.log(a[0]===b[0]);

    // let z = [1, "hgcv", 2, 3, 4];
    // let a = { name: "ritik" };
    // console.log(z);
    // console.log(...z); //it breaks array,object into its elements

    // let a="hi"
    // console.log(typeof a/5);       //Nan
    // console.log(typeof 3/a);       //Nan

    // console.log(typeof NaN);        //NaN is obtain when we divide non-numeric value like string,obj etc

    // let data=10 - -10;              //mathematics rule
    // console.log('data',data);

    // const set = [...new Set([1, 2, 3, 1, 2, 3, 4, 5, "hi", "bingo", "dd", "hi"])]; //set removes duplicacy of elements
    // console.log(set);

    // let a=["1","2","3","4"]
    // let b=["6","7","3","2"]
    // const arr=[...a,...b]
    // const c = arr.filter((it,index)=>!a.includes(it));
    // console.log(c);

    // const arr=[...a,...b]
    // console.log([...new Set(arr)]);
    // const ab=a.filter((it)=>b.includes(it))
    // console.log(ab);

    // let data = { name: "anil", age: 98 };
    // console.log(data);
    // console.log(delete data.name); //it returns trur or false ; wew can delete key-value by giving key name
    // console.log(data); //after deleting data is an empty {}
    // console.log(delete data); //we can delete property of data but not data object**

    // let data = ["anil", "peter", "bruce", "lee"];
    // const tt = delete data[1];
    // console.log(tt);
    //                  //it deletes (index with value) peter and write empty there
    // console.log(data);

    // const data = ["Hi", "hello", "king"];
    // const [y, z] = data; //ARRAY DESTRUCTURING gives first value of array element
    // console.log(y, z);
    // const [, , a] = data; //gives first arrray index value of array element [1]
    // console.log("a : ", a); //without z wanted to get 2nd value

    // let a = { name: "ritik", age: 12, saill: "rosk" };
    // let b = { school: "gbsss", saill: "rk" };     //merge 2 objects
    // console.log(...[a]);
    // let c = { ...a, ...b };
    // console.log(c);                             //if we have skill common in both objects we get saill key
    // c = { a, ...b };                             // of upper object and value of lower object
    // console.log(c);

    // a = 10;
    // console.log(typeof a); //Variable hoisting
    // console.log(a);
    // var a;
    // let a;

    // let a = [1, 2, 3, 4, 5];
    // let b = [4, 5, 6];
    // console.log(...a);                         //it doen't replace
    // let c = [...a, ...b]; //it takes both 4 in the array
    // console.log(c);
    // console.log([...new Set(c)]);

    // const a = [1, 2, 3, 4, 5, 4, 5, 6];

    // const tt = a.filter((item,index)=>a.indexOf(item)===index);
    // const tt = a.filter((item,index)=>a.findIndex((it)=>it===item)===index);
    // console.log("tt",tt);
    
    // const resp = a.filter((value, index, self) => {
    //   // console.log("value", value);
    //   // console.log("index", index);
    //   // console.log("self", self); //it is used to take orignal array
    //   // console.log(self.findIndex((it)=>console.log(it)));
    //   // console.log(self.findIndex((it)=>it===value));
    //   // console.log("self.indexOf(value)", self.indexOf(value));
    //   return self.findIndex((it)=>it===value) === index;
    //   // return self.indexOf(value) === index; //index of gives index of value
    // });
    // console.log("resp", resp);

    // let a = [1, 2, 3];
    // let b = [4, 5, 6];
    // let c = [...a, ...b]; //it merges 2 array
    // let d = { ...a }; //it makes array an object with index as keys
    // console.log(c);
    // console.log(...b); //make array elements out from array
    // console.log(d);

    // const result=false || {} || null;               //prints obj bcoz it's +ve and true value
    // const result1=false || '' || null;              //it picks last entry bcoz all 3 are false
    // console.log(result);
    // console.log(result1);

    // let name = "sidhu"; //let has block level scope & it can't pursue variable hoisting
    // function getName() {
    //   // let name = "jk";
    //   console.log(name); //local variable & global variable
    //   // let name="pal";
    // }
    // getName();

    // console.log(`${(x=>x)('I love')} to program`);

    // function sumValues(x, y, z) {
    //   console.log("x : ",x);
    //   console.log("y : ",y);
    //   console.log("z : ",z);
      
    //   return x + y + z;
    // }
    // console.log(sumValues(1, 5, 3)); //spread before array func(...[1,2]) converts it into string
    // console.log(...[1, 5, 3]);
    // console.log(sumValues(...[1, 5, 3]));

//     const name = "code";
//     console.log(typeof name); //name is not empty string so it's true, ! makes it false
//     console.log(!typeof name); //& when false it compared with (not empty string) it
//     console.log(!typeof name === "object"); //returns false false === "object" → false
//     console.log(!typeof name === "string");     //false === "string" → false
//     console.log(typeof false);
//     console.log(typeof name !== "object"); // true
// console.log(typeof name !== "string"); // false

    // let person = { name: "anil" };
    // console.log(person);
    // person.age = 30;
    // console.log(person);
    // //add new key in object
    // Object.seal(person); //after applying seal we cann't add new key but can modify person
    // // // console.log(person);
    // person.name = "king"; //cann't add new key but can modify the name key
    // person.class = "hello";
    // console.log(person);

    // const data = [2, 4, 5, 6, 0];
    // let string = "Hi this is Ritik";
    // let sp = string.split(" ");
    // console.log(sp);
    // let dele = data?.splice(0, 1);     //modifies orignal array
    // console.log(dele);
    // console.log(data);
    // let del = data?.slice(0, 1);        //gives new array
    // console.log(del);
    // console.log(data);
    // let shift = data?.shift();
    // console.log(data?.shift());
    // console.log("Removed array element", shift);
    // console.log("All rest array elements", data);

    // const data="true";
    // console.log(Boolean(data));                     //convert string to boolean
    // console.log(typeof !!data);

    // let a = 2;
    // setTimeout(() => {
    //   console.log(a);
    // }, 0); //it runs st before that the
    // a = 100; //value of a already become 100

    // let a = 1;
    // let b = 1;
    // let c = 2;
    // console.log(a === c--);
    // console.log(a === --c); //-- decrement happens so c=1 and returns true
    // console.log((a === b) === --c); //a===b is true and now boolean is compared to number

    // console.log([[[[]]]]);   //3 array element has length 1 and 4th have length 0

    // (Important)
    // function fruit() {
    //    name="apple";               //give value here
    //   console.log(name);
    //   var name = "apple12345"; //var gets hoisted with the default value of undefined
    //   let price = 20;
    // }
    // fruit();

    // for (let i = 0; i < 3; i++) {
    //   setTimeout(() => {
    //     //setTimeout etc mover in a stack of our code & runs at the end
    //     console.log(i); //var is decalared globally
    //   }, 1000);
    // }

    // let data = "size";
    // const bird = {
    //   size: "small",
    // };
    // console.log([data]); //so same case like log 2
    // console.log(bird[data]); //when we have to use var with object then obj[]
    // console.log(bird["size"]);
    // console.log(bird.size);
    // console.log(bird.data);     //undefined

    // let c = { name: "anil" };
    // let d;
    // d = c;
    // c.name = "kumar"; //we get latest value as memory loc of c and d are same
    // console.log(d.name);

    // let a = 3;
    // let b = new Number(3);
    // console.log(new Number(3)); //it's an object but it's value is 3
    // console.log(a == b);
    // console.log(a === b);

    // function sum(x, y) {
    //   return x + y;
    // }
    // console.log(sum(1, "2"));
    // console.log(sum(1, 2));

    // let number = 0;
    // console.log(number++); //post increment it prints 0 but the value become 1
    // console.log(++number); //pre increment value become 2 then printed
    // console.log(number);

    // function getAge(...args) {
    //   //spread operator makes it an array
    //   console.log(...args);
    //   console.log(typeof args); //type of arguement is undefined
    // }
    // getAge(21);

    // function getAge(...args){
    //     'use strict';                            //but use-strict says follow rules strictly,no hoisting etc
    //     let age = 21;                                 //whenever we don't define let,var etc it auto takes it var
    //     console.log(age);
    // }
    // getAge(21);
    

    // const sum = eval(10 * 10 + 5 - 2); //eval does the mathematical calculations
    // console.log(sum);

    // const obj = { cat: "one", bat: "two", cat: "repeat" }; //prints key of first a and value of second a
    // console.log(obj);

    // for (let i = 0; i < 5; i++) {
    //   if (i === 3) {
    //     continue; //continue will not print rest code when the condition matches
    //   }
    //   console.log(i);
    // }

    // const person = { name: "anil" };
    // function sayHi(age) {
    //   console.log(age);
    //   return `${this.name} is ${age}`;
    // }
    // console.log(sayHi.call(person, 21)); //it's called on it's own no callback is required
    // console.log(sayHi.bind(person, 21)); //returns function as it is with added properties
    // console.log(sayHi.bind(person, 21)()); //callback is required,bind is called manually

    // ***
    // function sayHello(){
        // return(()=>0);                      //it returns a function
        // return(()=>0)();                    //it returns a zero as fat arrow fun is called
    // }
    // console.log(sayHello()());
    // console.log(typeof sayHello());
    // console.log(typeof sayHello()());           //it also returna a number

    // console.log(typeof typeof 1);        //typeof 1 is number & number is a string which is a string

    // const numbers = [1, 2, 3];
    // numbers[6] = 11; //index 3,4,5 become empty
    // console.log(numbers);

    // const numbers = [1, 2, 3];
    // numbers[6] = numbers; //everytime at 6th index it pushes an array
    // console.log(numbers);

    // console.log(!!null);
    // console.log(!!"");
    // console.log(!!1);

    // console.log([..."anil"]);                 //it will break string and make it an array of string
    // console.log(..."anil");           //it make character out of string seperately
    // console.log(...['anil','hi']);    //it make word come out

    // // **Imp
    // let person={name:'anil'}        //mem loc. of obj and array is diff. so
    // const member=[person];          //when we null object it doesn't null the array
    // person=null;
    // console.log(member);
    // console.log(person);            //makes person null object

    // let data = 3 + 4 + "5";
    // console.log(data);
    // console.log(typeof data);

    // ***
    // console.log(typeof typeof false);
    // console.log(typeof 3+4+'6');        //o/p are performed from left to right,type of 3 is number+46
    // console.log(typeof (3+4+'6'));
    // console.log(typeof (3+4+ +'6'));        //if we add + sign in front of string(+"8") it become number

    // const a = [];
    // let b = a;
    // console.log(a === b);
    // console.log([] == []); //memory loc of both the array's is different

    // let data=[1,2,3].map((item)=>{
    //   console.log(typeof item==='number');
    //     // if(typeof item==='number') return;    //as it's not returning anything so it returns undefined
    //     return item*2;
    // });
    // console.log(data);

    // **Imp
    // function getInfo(member) {
    //   console.log(member); //memeber is obj inside member name key is modified
    //   member.name = "singh";
    // }
    // const person = { name: "Ritik" }; //when we pass object in a function call by refernce works
    // getInfo(person); //and when we changes it in function it auto changes in person obj
    // console.log(person); //due to same reference

    // (() => {
    //   let x = (y = 10); //undefined because x have block level scope
    //   console.log(x,y);
    // })(); //fat arrow function is called
    // console.log(typeof x);

    // (() => {        //Immediately Invoked Function Expres
    //  (IIFE)
    //   // var y;
    //   let x = (y = 10); //bcoz it's like let x=10,var y=10 & var has global scope
    //   console.log(x,y);
    // })(); //so y is accessible outside
    // console.log(typeof y);

    // (() => {
    //   var x = (y = 10); // var x makes it a block level scope while y is global scope
    // })();
    // console.log(typeof x);
    // console.log("x : ", x);
    // console.log(typeof y);

    // let x = 100;
    // (() => {
    //   var x = 20; //now it act's as block bcoz x is already declared outside
    // })(); //so y is accessible outside
    // console.log(x);

    // console.log(!true-true);        //true=1 !true=0 so 0-1=-1

    // 1+10(number bcoz string is converted to number by + before string)

    // STRING QUESTIONS

    // let str = "Hello, How are you?";

    //1.Convert string in only one array

    // console.log([str]);
    // console.log(str.split())       //makes strin a array
    // console.log(str.split(""));           //give array of each characters
    // console.log(str.split(" "));         //give array of characters

    //2.Convert string to array with each character
    // console.log(...str);
    // console.log([...str]);  //same as str.split("")

    //3.Convert string to array on the basis of a chacter
    // console.log(str.split('a'));

    //4.replace any chacter
    // console.log(str.replace('H','W'));      //works on single character
    // console.log(str.replace(/H/g,'W'));     //works for all characters

    // 5.get string from subString
    // console.log(str.substring(0,5));

    //6.Remove first character from string
    // console.log(str.substring(0,str.length));

    // 7.reverse a string
    // console.log(str.split("").reverse().join(""));    //array can be reversed not string

    // 8.Remove empty spaces
    // console.log(str.trim());

    // 9.Concat two string
    // let a="hello";
    // let b="Candidate"
    // let c= a+' ' +b
    // console.log(String(c));

    // const b = [1, 2, 3];
    // console.log("b", b.push(4));
    // console.log("b", b);

    // ARRAY QUESTIONS

    // let data = [2, 4, 6, 3, 7, 3, 6, 4, 9, 5];

    // console.log(data.reduce((x,y)=>x+y));

    // let sum = 0
    // function ss(payload){
    //   payload.forEach(element => {
    //     sum += element
    //   });
    //   return sum
    // }
    // console.log(ss(data));
    

    // function summ(dd){
    //   let sm = 0;
    //   dd.forEach(element => {
    //     sm += element
    //   });
      
    //   return sm
    // }

    // console.log(summ(data));

    // function sum(dd) {
    //   let sum = 0;
    //   for (let index = 0; index < dd.length; index++) {
    //     sum += dd[index];
    //   }
    //   return sum;
    // }

    // console.log(sum(data));

    // var sum = 0;
    // const aa = data.forEach((e, i) => {
    //   sum += e;
    // });
    // console.log(sum);

    // 1.Find sum of all array elements
    // let sum = data.reduce((x, y) => x + y, 0);
    // console.log(sum);

    // let sum = 0;
    // for (let index = 0; index < data.length; index++) {
    //   sum += data[index];
    // }
    // console.log("sum", sum);

    // let sum = 0;
    // for (let i = 0; i < data.length; i++) {
    //   sum += data[i];
    // }
    // console.log(sum);

    // const a = [1,4,5]
    // const sum = (data)=>{
    //   let sums = 0
    //   for (let i = 0; i < data.length; i++) {
    //     console.log(i);
        
    //   sums += a[i]
    // }
    // return sums
    // }

    // console.log("aa",sum(a));
    
    // var sum = 0
    // for (let index = 0; index < a.length; index++) {
    //   sum += a[index];
    // }
    // console.log(sum);

    // let x =  10;  //assignment statement in JavaScript that uses the comma operator to evaluate multiple expressions and assign the result of the last expression to the variable x
    // x = (x++, x); //first perform action second prints the outcome
    // x = ((x += 10), x);
    // x = ((x += 10), 6);
    // x = ((x += 10), 6); //, 6 is a comma operator that evaluates expressions from left to right and returns the value of the last expression, which is 6.
    // console.log(x);

    // CLOSURES
    //a closure gives you access to an outer function's scope from an inner function.

    // const teacher = () =>{
    //   let x = 10

    //   return function innerFunc(arg){
    //     return arg+x
    //   }
    // }

    // const tt = teacher();
    // console.log(tt);
    // console.log(tt(5));
    
    

    // const closuress =()=>{
    //   let x = 10
    //   console.log("Outer Function");
      
    //   return function innerFunc(){
    //     console.log("Inner Function")
    //     return x+12
    //   }
    // }

    // console.log(closuress()());
    

    // function outer(){
    //   let x = 10;
    //   return function inner(){
    //     return x
    //   }
    // }

    // const outerFunc=()=>{
    //   let num = 10
    //   return function innerFunc(){
    //     return num;
    //   }
    // }

    // console.log(outerFunc()());
    

    // console.log(outer()());

    // function outer(){
    //   const num = 10;
    //   console.log("outer function");
    //   return function inner(){
    //     console.log("num",num);
    //     console.log("inner Function");
    //   }
    // }

    // function outFunc() {
    //   const ab = 10;
    //   return function innerfunc() {
    //     console.log(ab);
    //   };
    // }

    // const closure = outFunc();
    // console.log(closure());

    // function outFunc(){
    //   const a = 8
    //   console.log("OUter Called",a);
    //   return function innerFunc(){
    //     let b = 3;
    //     console.log("inner called ",a + b);
    //     return a + b
    //   }
    // }

    // console.log(outFunc()());

    // console.log(outer()());

    // function out(){
    //   console.log("out");
    //   const a = 10

    //  return function iner(){
    //     console.log("iner",a);
    //   }
    // }

    // console.log(out()());
    // function outerFunction(outerVariable) {
    //   console.log("outerVariable", outerVariable);
    //   // This is the inner function, which is a closure (LEXICAL SCOPING)
    //   function innerFunction(innerVariable) {
    //     console.log("innerVariable", innerVariable);
    //     console.log(outerVariable + innerVariable);
    //   }

    //   // Return the inner function
    //   return innerFunction || "No Paraeter passes";
    // }
    // outerFunction(12)(13);

    // Create a closure by calling outerFunction
    // const closure = outerFunction(10);
    // console.log("closure",closure);     //When we call outerFunction(10), it returns the innerFunction, creating a closure.
    // //The innerFunction now has access to the outerVariable, even though outerFunction has finished executing.
    // // Use the closure
    // closure(5); // Outputs: 15

    // function x(){
    //   const a=7;
    //   function y(){
    //     console.log(a);     //lexical scoping
    //   }
    //   y();
    // }
    // console.log("hgf");
    
    // x();

    //when functions return from their lexical scope they still maintain ther position
    // function x() {
    //   var a = 7;
    //   function y() {
    //     console.log(a); //lexical scoping
    //   }
    //   return y;
    //   // return function y() {
    //   //   console.log(a); //this is same
    //   // };
    // }

    // console.log(x()); //it calls x and get whole y function as value
    // x()();      //same as z
    // var z = x();
    // console.log(z);
    // z();      //now again when z is called it triggers to the same y function

    // function x() {
    //   var a = 7;
    //   function y() {
    //     console.log(a);        //this is same
    //   }
    //   a=100;
    //   return y
    // }
    // x()()

    // function z() {
    //   var b = 900;
    //   function x() {
    //     var a = 7;
    //     function y() {
    //       console.log(a, b); //this is same
    //     }
    //     y();
    //   }
    //   x();
    // }
    // z();

    // function x() {
    //   for (var i = 1; i <= 5; i++) {
    //     function close(i) {
    //       //every time this i creates a new memory refrence
    //       setTimeout(() => {
    //         console.log(i);
    //       }, i * 1000);
    //     }
    //     close(i);
    //     // console.log("Nameste");
    //   }
    // }
    // x();

    //TIMER
    // function startTimer(data) {
    //   for (let index = 0; index <= data; index++) {
    //     setTimeout(() => {
    //       console.log(index);
    //     }, index * 1000);
    //   }
    // }

    // startTimer(5);

    // function timer(data){
    //   for (let i = 0; i < data; i++) {
    //     setTimeout(() => {
    //     console.log(i);
    //   }, 1000 * i);
    //   }
    // }

    // console.log(timer(5));
        

    //THIS
    //In the global level this points to window object
    //window is global object which is created along with global execution context

    // FLATTING Array

    // var array = [1, 2, 3, [7, 8, [9]], 4, [5], 6];
    // const recusion = (data)=>{
    //   const emptyArr = []
    //   data.forEach((item)=>{
    //     if(Array.isArray(item)){
    //       emptyArr.push(...recusion(item))
    //     }
    //     else{
    //       emptyArr.push(item)
    //     }
    //   })
    //   console.log("emptyArr",emptyArr);
    //   return emptyArr
      
    // }

    // console.log(recusion(array));
    



    // var array = [1, 2, 3, [7, 8, [9]], 4, [5], 6];

    // function flatArr(data){
    //   const emptyArr = []
    //   data.forEach((element) => {
    //     if(Array.isArray(element)){
    //       emptyArr.push(...flatArr(element))
    //     }
    //     else{
    //       emptyArr.push(element)
    //     }
    //   });

    //   return emptyArr
    // }

    // console.log(flatArr(array));
    


    //   var obj={name:"ritik"}
    // function flattenArray(arr) {
    //   var flattened = [];
    //   console.log("flattened",flattened);
    //   arr.forEach(function (item) {
    //     console.log("item", item);
    //     console.log("isArray", Array.isArray(item));
    //     if (Array.isArray(item)) {
    //       flattened = flattened.concat(flattenArray(item));
    //       console.log("flattenedArray",flattened);
    //     } else {
    //       flattened.push(item);
    //     }
    //   });

    //   return flattened;
    // }
    // var flattenedArray = flattenArray(array);
    // console.log(flattenedArray);

    // PALENDROME
    // const input = window.prompt("Enter name")
    // function isPalen(text){
    //   const strLength = text.length;
    //   for (let i = 0; i < strLength/2; i++) {
    //     if(text[i] !== text[strLength - i - 1]){
    //       return false
    //     }

    //     return true
    //   }
    // }

    // console.log("input",input);
    
    // const revInput = input.split('').reverse().join('');
    // console.log("revInput",revInput);
    // console.log(input===revInput ? "Palendrome" : "Not Palendrome");
    
    

    // console.log(isPalen(input) ? "Palendrome" : "Not Palendrome" );
    

    // const a = window.prompt("Enter value of a");
    // const straight = a.split('').reverse().join('');
    // console.log(a===straight ? "Palendrome" : "Not Palendrome");
    
    // console.log("straight",straight);
    
    // const isPalen=(data)=>{
    //   const strLength = data.length
    //   for (let i = 0; i < strLength/2; i++) {
    //     if(data[i]!==data[strLength - 1 -i]){
    //       return "Not Palendrome";
          
    //     }
    //   }
    //   return "Palendrome";
    // }

    // console.log(isPalen(a));
    
    // If first and last chacter are same it's palendrome
    // function checkPalindrome(string) {
    //   console.log("string",string);
    //   console.log("string",string[0]);

    //   const len = string.length;
    //   console.log("len",len);
    //   for (let i = 0; i < len / 2; i++) {
    //     console.log("i : ",i);
    //     console.log("string[i]",string[i]);
    //     console.log("string[len - 1 - i]",string[len - 1 - i]);
    //     if (string[i] !== string[len - 1 - i]) {
    //       return "It is not a palindrome";
    //     }
    //   }
    //   return "It is a palindrome";
    // }
    // const string = prompt("Enter a string: ");
    // const value = checkPalindrome(string);
    // console.log(value);

    //PROMISES
    // AN object there are 3 states of promise object,pending,resolved,rejected
    // resolved .then()
    // rejected .catch()

    // const prom1 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve("Promise 1 is resolved")
    //   }, 110);
    // })

    // const prom2 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve("Promise 2 is resolved")
    //   }, 800);
    // })

    // const prom3 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve("Promise 3 is resolved")
    //   }, 600);
    // })

    // Promise.race([prom1,prom2,prom3])
    // .then((resp)=>console.log("resp",resp))
    // .catch((err)=>console.log("err",err))



    // const newProm1 = new Promise((resolve,reject)=>{
    //   setTimeout(()=>resolve("1"),1000)
    // })

    // const newProm2 = new Promise((resolve,reject)=>{
    //   setTimeout(()=>reject("2"),200)
    // })

    // const newProm3 = new Promise((resolve,reject)=>{
    //   setTimeout(()=>resolve("3"),3000)
    // })

    // newProm.then((resp)=>console.log(resp)).catch((err)=>console.log("Err",err))
    // Promise.allSettled([newProm1,newProm2,newProm3])
    // .then((resp)=>console.log("resp",resp))
    // .catch((err)=>console.log("err",err))

    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(()=>{
    //     resolve("Resolved 1")
    //   },1000)
    // })

    //  const promise2 = new Promise((resolve, reject) => {
    //   setTimeout(()=>{
    //     reject("Resolved 2")
    //   },300)
    // })

    //  const promise3 = new Promise((resolve, reject) => {
    //   setTimeout(()=>{
    //     resolve("Resolved 3")
    //   },1400)
    // })

    // const resp = Promise.allSettled([promise1,promise2,promise3]).then((res)=>console.log("resolve : ",res)).catch((err)=>console.log("error: ",err))

    // const prmise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve("Promise 1")
    //   }, 1000);
    // })

    // const prmise2 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     reject("Promise 2")
    //   }, 600);
    // })

    // const prmise3 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve("Promise 3")
    //   }, 1200);
    // })

    // Promise.all([prmise1,prmise2,prmise3]).then((res)=>console.log(res)).catch((err)=>console.log(err))

    // const prom = new Promise((resolve, reject) => {
    //   if(true){
    //     return console.log("It is RESOLVED");
    //   }
    //   else console.log("It is Rejected");
    // })

    // const dd = prom.then((re)=>console.log(res)).catch("error")

    // const hell = new Promise((res, rej) => {
    //   if (true) {
    //     console.log("It is RESOLVED");
    //   } else {
    //     console.log("It is REJECTED");
    //   }
    // });

    // hell
    //   .then((res) => console.log(res))
    //   .catch((err) => console.log("err", err));

    // const promise1 = Promise.resolve(123);
    // console.log("promise1", promise1);
    // promise1.then((value) => {
    //   console.log(value);
    // });
    // const resp = new Promise.resolve(123).then((value) => console.log("value"));
    // console.log("resp", resp);

    // const myPromise = new Promise((resolved, rejected) => {
    //   const a = 2;
    //   const b = 12;
    //   const c = a + b;
    //   if (c === 4) {
    //     resolved("yes it's correct ");
    //   } else {
    //     rejected("no it's not");
    //   }
    // });

    // myPromise
    //   .then((data) => {
    //     console.log(data);
    //   })
    //   .catch((err) => {
    //     console.log("err", err);
    //   });

    // promise.race
    // it return the firstly resolved or rejected promise

    // const pr1 = new Promise((resolve, reject) => {
    //   setTimeout(()=>resolve("Resolve First"),1000)
    // })

    
    // const pr2 = new Promise((resolve, reject) => {
    //   setTimeout(()=>resolve("Resolve Second"),700)
    // })

    
    // const pr3 = new Promise((resolve, reject) => {
    //   setTimeout(()=>reject("Error"),400)
    // })

    // const res = Promise.any([pr1,pr2,pr3]).then((resp)=>console.log(resp)
    // ).catch((err)=>console.log(err)
    // )

    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve("one");
    //   }, 500);
    // });

    // const promise2 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve("two");
    //   }, 200);
    // });

    // const promise3 = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     reject("It is rejected");
    //   }, 90);
    // });

    // Promise.race([promise1, promise2, promise3])
    //   .then((value) => {
    //     console.log("value", value);
    //   })
    //   .catch((err) => console.log("err", err));

    // promise.all; (All promises should be resolved) [Gives array of values if all promises are resolved and reason if rejected]
    // It takes an iterable of promises as input and returns a new promise
    // that resolves when all the promises in the iterable have resolved successfully. The
    // resolved values of all the promises are collected into an array in the same order as the original promises.
    // It doesn't executes with less sec

    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 1 resolved"), 1000);
    // });

    // const promise2 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 2 resolved"), 500);
    // });

    // const promise3 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 3 resolved"), 800);
    // });

    // Promise.all([promise1, promise2, promise3])
    //   .then((results) => {
    //     console.log("All promises resolved:", results);
    //   })
    //   .catch((error) => {
    //     console.log("One of the promises rejected:", error);
    //   });

    // promise.allsettled()
    // gives array of with status key as fulfilled or rejected and value if resolved and reason if rejected
    // It doesn't executes with less sec
    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 1 resolved"), 1000);
    // });

    // const promise2 = new Promise((resolve, reject) => {
    //   setTimeout(() => reject(new Error("Promise 2 rejected")), 500);
    // });

    // const promise3 = new Promise((resolve, reject) => {
    //   setTimeout(() => resolve("Promise 3 resolved"), 800);
    // });

    // Promise.allSettled([promise1, promise2, promise3]).then((results) => {
    //   console.log("All promises settled:", results);
    // });

    // promise.any
    // run all promises untill any one one of is resolved and returns firstly resolved promise
    // const promise1 = new Promise((resolve, reject) => {
    //   setTimeout(() => reject("Promise 1 resolved"), 1000);
    // });

    // const promise2 = new Promise((resolve, reject) => {
    //   setTimeout(() => reject(new Error("Promise 2 rejected")), 500);
    // });

    // const promise3 = new Promise((resolve, reject) => {
    //   setTimeout(() => reject("Promise 3 resolved"), 800);
    // });

    // Promise.any([promise1, promise2, promise3])
    //   .then((result) => {
    //     console.log("At least one promise resolved:", result);
    //   })
    //   .catch((errors) => {
    //     console.log(errors);
    //   });

    // const myPromise = new Promise((resolve, reject) => {
    //   if (false) {
    //     resolve("It is true");
    //   } else {
    //     reject("It is false");
    //   }
    // })
    //   .then((resp) => {
    //     console.log("resp", resp);
    //   })
    //   .catch((err) => {
    //     console.log("err", err);
    //   });

    //   console.log(myPromise);

    // Template String
    // const a = "Ritik";
    // const b = "Chauhan";
    // console.log("Welcome to team " + a + ". Hi " + b + "");
    // console.log(`Welcome to team ${a}. Hi ${b}`);

    // Object Dstructuring
    // const details = {
    //   name: "ritik",
    //   age: 22,
    // };

    // const name = details.name;
    // const age = details.age;
    // console.log(name, age);

    // const { name, age } = details;
    // const { name: companyName, age } = details;

    // console.log(name,age);
    // console.log(companyName,age);

    // Array Dstructuring
    // const arr = ["a", "b", "c", "d"];
    // console.log(arr[0]);

    // const arr = ["a", "b", "c", "d"];
    // const [p, q, r, s] = arr;
    // console.log("p : ", p);

    //SPREAD AND REST
    // const oldArr = [1, 2, 3, 4];
    // console.log(...oldArr);
    // const newArr = [...oldArr, 2, 3, 4];
    // console.log("newArr", newArr);

    // function sum(a, b, ...numbers) {
    //   console.log(a, b);
    //   console.log("numbers", numbers); //it gather all arguements into a single array
    //   return numbers.reduce((total, num) => total + num, 0);
    // }
    // console.log(sum(1, 2, 3, 4, 5));

    //DIfference between normal function and fat-arrow function
    // function add(a, b) {
    //   return a + b; //no implicit return for single statement
    // }

    // const add = (a, b) => a + b; //implicit return for single statement
    // console.log(add(2, 3));

    // var namesq = "111"
    // let obj={
    //   namesq:"ritik",
    //   normaFunc(){
    //     console.log("Normal ",this.namesq);
    //   },
    //   fatArrowFunc:()=>{
    //     console.log("Fat "+ this.namesq);
    //   }
    // }

    // console.log(obj.normaFunc());
    // console.log(obj.fatArrowFunc());
    

    // let userInfo={
    //   name:"code Improve",
    //   fullName(){
    //     console.log(this.name + "Normal Function");
    //   },
    //   fullName2:()=>{
    //     console.log(this.name + "Fat Function");      //don't have their own this value
    //   }
    // }

    // console.log("this ", this);

    // let userInfo = {
    //   name: "code Improve",
    //   fullName() {
    //     const name = () => {
    //       console.log(this.name);
    //       console.log(this.name + "Fat Function");    //lexical scoping it found name in parent
    //     };
    //     name();
    //     console.log(this.name + "Normal Function");
    //   },
    //   fullName2: () => {
    //     console.log("this ", this);   //value of this inside a fat-arrow fn is same as otside a fn
    //     console.log(this.name + "Fat Function"); // Arrow functions do not have their own this context. Instead, they capture the value of this from the surrounding scope
    //   },
    // };

    // userInfo.fullName();
    // userInfo.fullName2();

    //Currying:function is transformed into a sequence of functions, each taking a single argument.
    // This curried function works by creating closures that capture each argument one by one until all the necessary arguments have been provided

    // function a(x){
    //   return function b(y){
    //     return function c(z){
    //       return x+y+z
    //     }
    //   }
    // }

    // console.log(a(3)(4)(5));
    

    // function a(x){
    //   return function b(y){
    //     return function c(z){
    //       return x+y+z
    //     }
    //   }
    // }

    // const func=(x,y,z)=>{
    //   return x+y+z
    // }

    // console.log(a(2)(4)(2));
    // console.log(func(2,4,2));
    


    // const normalSum = (a,b,c)=>a+b+c
    // console.log(normalSum(2,5,6));
    // function currySumFunc(a){
    //   return function(b){
    //     return function(c){
    //       return a+b+c
    //     }
    //   }
    // }

    // console.log(currySumFunc(1)(2)(3));
    

    
    // const multiArgFunction = (a, b, c) => a + b + c;
    // console.log(multiArgFunction(1, 2, 3)); // 6

    // const curryUnaryFunction = (a) => (b) => (c) => a + b + c;
    // function curr(a){
    //   return function(b){
    //     return function(c){
    //       return a+b+c
    //     }
    //   }
    // }

    // console.log(curr(2)(3)(5));


    // function curryUnaryFunction(a) {
    //   return function (b) {
    //     return function (c) {
    //       return a + b + c;
    //     };
    //   };
    // }
    // console.log(curryUnaryFunction(1)(2)(3));

    // High order function:Ex map, filter, and reduce,setTimeout(), setInterval(),fetch().then()
    // A higher-order function is a function that accepts another function as an argument or returns a function as a return value.
    // Takes another function as an argument (e.g., map, filter, forEach), OR
    // Returns another function.


    // function highfunc(x){
    //   const y = 10;
    //   return function(y){
    //     return x+y
    //   }
    // }

    // const highfuncVar = highfunc(5) 
    // console.log(highfuncVar(10));
    


    // const multiplier=(num)=>{
    //   return function(numInside){
    //     return num*numInside
    //   }
    // }

    // const highFunc = multiplier(2);
    // console.log(highFunc(5));
    


//     function fun() {
//     console.log("Hello, World!");
// }
// function fun2(action) {
//     action();
//     action();
// }

// console.log(fun2(fun));


// const hightOrder=(fn)=>{
//   return function(name){
//     fn(name)
//   }
// }


// const lowFunc=(dd)=>{
//   console.log("Hello " + dd);
// }
// const hf = hightOrder(lowFunc)
// console.log(hf);

// console.log(hf("ritik"));


// fun2(fun);

    // function greaterThan(n) {
    //   //greaterThan is a higher-order function because it returns another function.
    //   console.log("n", n);

    //   return (m) => {
    //     console.log("m", m,n);
    //     return m > n 
    //   };
    // }

    // let greaterThan10 = greaterThan(10);   //it returns return statement and the this is called with 11 as value
    // console.log("greaterThan10", greaterThan10);
    // console.log(greaterThan10(11)); //greaterThan10 becomes a function generated by greaterThan(10), specifically a function that checks if its input is greater than 10

//     function multiplier(factor) {
//       console.log("factor",factor);
//   return function (num) {
//     console.log("num",num);
//     return num * factor;
//   };
// }

// const double = multiplier(2);
// console.log("double",double);

// console.log(double(5)); // Output: 10


    // const firstOrderFunc = () =>
    //   console.log("Hello, I am a First order function");
    // function higherOrder(ReturnFirstOrderFunc) {
    //   //A higher-order function is a function that takes one or more functions as arguments or returns a function as its resul
    //   ReturnFirstOrderFunc();
    // }
    // higherOrder(firstOrderFunc);

    // callback function
    // Call back is a function passed as an arguement to another function which is then invoked inside the outer function
    // to complete some kind of routine or action
    

    // function students(){
    //   console.log("Students Called")
    // }
    // function teacher(data){
    //   console.log("Teachers")
    //   data()
    // }
    // teacher(students)

    // function students(){
    //   console.log("Students here");
    // }

    // function teachers(data){
    //   console.log("Teachers here");
    //   data()
    // }

    // teachers(students)

    // const studentFunction=()=>{
    //   console.log("Students");
    // }

    // const teachersFunction=(callback)=>{
    //   console.log("Teachers");
    //   callback()
    // }

    // teachersFunction(studentFunction)


    // function students(calbck){
    //   console.log("students called");
    //   // calbck();
    //   setTimeout(()=>{
    //     calbck();             //if students delayed

    //   },2000)

    // }
    // function teachers(){
    //   console.log("teachers called");
    // }

    // students(teachers)

    // Pure function (No Side Effects)
    // pure function are function that accept an input and returns a
    // value without modifying any data outside its scope

    // const result = (a,b)=>{
    //   return a+b
    // }

    // console.log(result(3,8));
    

    // let resultVar = 0
    // console.log(resultVar);

    // function resultFunc(a,b){
    //  resultVar = a+b
    // }
    // console.log(resultFunc(2,67));
    // console.log("startIndex",resultVar);
    
    
    

    // let result = 0
    // console.log("result",result);

    // function sum(a,b){
    //   result = a + b
    //   // return result
    // }

    // sum(2,7)
    // console.log("result11",result);
    


    // function add(a, b) {
    //   return a + b;
    // }

    // console.log(add(1,2));

    // let result = 0; // External state
    // console.log("result", result);
    // function impureAdd(a, b) {
    //   result = a + b; // Modifies external state
    //   return result;
    // }

    // console.log(impureAdd(2, 3));
    // console.log("result", result);

    // let result = 0
    // console.log("result",result);

    // const imapureFunc = (x,y) =>{
    //   return x+y
    // }

    // console.log(imapureFunc(2,6));


    // ----------------------------------
    // -----------------------------------

//     const nestedObj = {
//   name: "John",
//   address: {
//     city: "New York",
//     zip: {
//       code: 10001,
//       plus4: 1234
//     }
//   }
// };

// {
//   "name": "John",
//   "address.city": "New York",
//   "address.zip.code": 10001,
//   "address.zip.plus4": 1234
// }


// function flattenObject(obj, parentKey = '', result = {}) {
//   for (let key in obj) {
//     const newKey = parentKey ? `${parentKey}.${key}` : key;
//     if (typeof obj[key] === 'object' && obj[key] !== null) {
//       flattenObject(obj[key], newKey, result);
//     } else {
//       result[newKey] = obj[key];
//     }
//   }
//   return result;
// }

// const flat = flattenObject(nestedObj);
// console.log(flat);


  // const flatObj = (obj,parentKey='',result={})=>{
  //   for (const key in obj) {
  //     const newKey = parentKey ? `${parentKey}.${key}` : key;
  //     if(typeof obj[key]==='object' && obj[key] !== null){    //if zip is null
  //       flatObj(obj[key],newKey,result)
  //     }
  //     else{
  //       result[newKey] = obj[key]
  //     }
  //   }

  //   return result
  // }
      
  // console.log("nestedObj",flatObj(nestedObj));
  
  </script>

  <body>
    <div>
      <!-- Event Bubbling -->
      <div onclick="alert('First Div')">
        //3
        <img onclick="alert('Second Div')">
          //2 <button onclick="alert('Button alert')">Button</button> //1
          <p>Hello Ritik chauhan vats </p>
          <h3>Village _ Dahisra</h3>
          <h3>District - Sonipat</h3>
          <img src="./woman.png" alt="Girl in a jacket" width="500" height="600">
        </div>
      </div>
    </div>
  </body>
</html>
<!-- 
type Geeks = {
  name: string;
  age: number;
};

type MoreGeeks = {
  email: string;
};

type CombinedGeeks = Geeks & MoreGeeks;

const gfg: CombinedGeeks = {
  name: "kgowda",
  age: 20,
  email: "kgowda@gmail.com"
};

console.log(gfg); -->

<!-- interface Geeks {
  name: string;
  age: number
}

interface Geeks {
  email: string;
}

// Using the merged interface
const gfg: Geeks = {
  name: &quot; kgowda&quot;,
  age: 20,
  email: &quot; kgowda@gmail.com&quot;
};

console.log(gfg); -->
<!-- Interface support the use of object -->


<!-- 
{
  "Resources": {
      "SimpleEC2Instance": {
          "Type": "AWS::EC2::Instance",
          "Properties": {
              "InstanceType": "t3.micro",
              "ImageId": "ami-0ff8a91507f77f867",
              "Tags": [
                  {
                      "Key": "Name",
                      "Value": "MySimpleInstance"
                  }
              ]
          }
      }
  }
} -->